/* 
 * FIWARE-NGSI v2 Specification
 *
 * TODO: Add a description
 *
 * OpenAPI spec version: 1.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using ContextBrokerLibrary.Client;
using ContextBrokerLibrary.Model;
using IO.Swagger.Model;
using RestSharp;

namespace ContextBrokerLibrary.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IEntitiesApi : IApiAccessor
    {
        #region Synchronous Operations

        /// <summary>
        /// Create Entity
        /// </summary>
        /// <remarks>
        /// The payload is an object representing the entity to be created. The object follows the JSON entity representation format (described in a \&quot;JSON Entity Representation\&quot; section). Response: * Successful operation uses 201 Created (if upsert option is not used) or 204 No Content (if   upsert option is used). Response includes a &#x60;Location&#x60; header with the URL of the   created entity. * Errors use a non-2xx and (optionally) an error payload. See subsection on \&quot;Error Responses\&quot; for   more details.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"></param>
        /// <param name="contentType"></param>
        /// <param name="options">Options dictionary (optional)</param>
        /// <returns></returns>
        void CreateEntity(CreateEntityRequest body, string contentType, string options = null);

        /// <summary>
        /// Create Entity
        /// </summary>
        /// <remarks>
        /// The payload is an object representing the entity to be created. The object follows the JSON entity representation format (described in a \&quot;JSON Entity Representation\&quot; section). Response: * Successful operation uses 201 Created (if upsert option is not used) or 204 No Content (if   upsert option is used). Response includes a &#x60;Location&#x60; header with the URL of the   created entity. * Errors use a non-2xx and (optionally) an error payload. See subsection on \&quot;Error Responses\&quot; for   more details.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"></param>
        /// <param name="contentType"></param>
        /// <param name="options">Options dictionary (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> CreateEntityWithHttpInfo(CreateEntityRequest body, string contentType,
            string options = null);

        /// <summary>
        /// List Entities
        /// </summary>
        /// <remarks>
        /// Retrieves a list of entities that match different criteria by id, type, pattern matching (either id or type) and/or those which match a query or geographical query (see [Simple Query Language](#simple_query_language) and  [Geographical Queries](#geographical_queries)). A given entity has to match all the criteria to be retrieved (i.e., the criteria is combined in a logical AND way). Note that pattern matching query parameters are incompatible (i.e. mutually exclusive) with their corresponding exact matching parameters, i.e. &#x60;idPattern&#x60; with &#x60;id&#x60; and &#x60;typePattern&#x60; with &#x60;type&#x60;. The response payload is an array containing one object per matching entity. Each entity follows the JSON entity representation format (described in \&quot;JSON Entity Representation\&quot; section). Response code: * Successful operation uses 200 OK * Errors use a non-2xx and (optionally) an error payload. See subsection on \&quot;Error Responses\&quot; for   more details.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A comma-separated list of elements. Retrieve entities whose ID matches one of the elements in the list. Incompatible with &#x60;idPattern&#x60;. (optional)</param>
        /// <param name="type">comma-separated list of elements. Retrieve entities whose type matches one of the elements in the list. Incompatible with &#x60;typePattern&#x60;. (optional)</param>
        /// <param name="idPattern">A correctly formated regular expression. Retrieve entities whose ID matches the regular expression. Incompatible with &#x60;id&#x60;. (optional)</param>
        /// <param name="typePattern">A correctly formated regular expression. Retrieve entities whose type matches the regular expression. Incompatible with &#x60;type&#x60;. (optional)</param>
        /// <param name="q">A query expression, composed of a list of statements separated by &#x60;;&#x60;, i.e., q&#x3D;statement1;statement2;statement3. See [Simple Query Language specification](#simple_query_language). (optional)</param>
        /// <param name="mq">A query expression for attribute metadata, composed of a list of statements separated by &#x60;;&#x60;, i.e., mq&#x3D;statement1;statement2;statement3. See [Simple Query Language specification](#simple_query_language). (optional)</param>
        /// <param name="georel">Spatial relationship between matching entities and a reference shape. See [Geographical Queries](#geographical_queries). (optional)</param>
        /// <param name="geometry">Geografical area to which the query is restricted. See [Geographical Queries](#geographical_queries). (optional)</param>
        /// <param name="coords">List of latitude-longitude pairs of coordinates separated by &#x27;;&#x27;. See [Geographical Queries](#geographical_queries). (optional)</param>
        /// <param name="limit">Limits the number of entities to be retrieved (optional)</param>
        /// <param name="offset">Establishes the offset from where entities are retrieved (optional)</param>
        /// <param name="attrs">Comma-separated list of attribute names whose data are to be included in the response. The attributes are retrieved in the order specified by this parameter. If this parameter is not included, the attributes are retrieved in arbitrary order. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. (optional)</param>
        /// <param name="metadata">A list of metadata names to include in the response. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. (optional)</param>
        /// <param name="orderBy">Criteria for ordering results. See \&quot;Ordering Results\&quot; section for details. (optional)</param>
        /// <param name="options">Options dictionary (optional)</param>
        /// <returns>List&lt;ListEntitiesResponse&gt;</returns>
        List<ListEntitiesResponse> ListEntities(string id = null, string type = null, string idPattern = null,
            string typePattern = null, string q = null, string mq = null, string georel = null, string geometry = null,
            string coords = null, double? limit = null, double? offset = null, string attrs = null,
            string metadata = null, string orderBy = null, string options = null);

        /// <summary>
        /// List Entities
        /// </summary>
        /// <remarks>
        /// Retrieves a list of entities that match different criteria by id, type, pattern matching (either id or type) and/or those which match a query or geographical query (see [Simple Query Language](#simple_query_language) and  [Geographical Queries](#geographical_queries)). A given entity has to match all the criteria to be retrieved (i.e., the criteria is combined in a logical AND way). Note that pattern matching query parameters are incompatible (i.e. mutually exclusive) with their corresponding exact matching parameters, i.e. &#x60;idPattern&#x60; with &#x60;id&#x60; and &#x60;typePattern&#x60; with &#x60;type&#x60;. The response payload is an array containing one object per matching entity. Each entity follows the JSON entity representation format (described in \&quot;JSON Entity Representation\&quot; section). Response code: * Successful operation uses 200 OK * Errors use a non-2xx and (optionally) an error payload. See subsection on \&quot;Error Responses\&quot; for   more details.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A comma-separated list of elements. Retrieve entities whose ID matches one of the elements in the list. Incompatible with &#x60;idPattern&#x60;. (optional)</param>
        /// <param name="type">comma-separated list of elements. Retrieve entities whose type matches one of the elements in the list. Incompatible with &#x60;typePattern&#x60;. (optional)</param>
        /// <param name="idPattern">A correctly formated regular expression. Retrieve entities whose ID matches the regular expression. Incompatible with &#x60;id&#x60;. (optional)</param>
        /// <param name="typePattern">A correctly formated regular expression. Retrieve entities whose type matches the regular expression. Incompatible with &#x60;type&#x60;. (optional)</param>
        /// <param name="q">A query expression, composed of a list of statements separated by &#x60;;&#x60;, i.e., q&#x3D;statement1;statement2;statement3. See [Simple Query Language specification](#simple_query_language). (optional)</param>
        /// <param name="mq">A query expression for attribute metadata, composed of a list of statements separated by &#x60;;&#x60;, i.e., mq&#x3D;statement1;statement2;statement3. See [Simple Query Language specification](#simple_query_language). (optional)</param>
        /// <param name="georel">Spatial relationship between matching entities and a reference shape. See [Geographical Queries](#geographical_queries). (optional)</param>
        /// <param name="geometry">Geografical area to which the query is restricted. See [Geographical Queries](#geographical_queries). (optional)</param>
        /// <param name="coords">List of latitude-longitude pairs of coordinates separated by &#x27;;&#x27;. See [Geographical Queries](#geographical_queries). (optional)</param>
        /// <param name="limit">Limits the number of entities to be retrieved (optional)</param>
        /// <param name="offset">Establishes the offset from where entities are retrieved (optional)</param>
        /// <param name="attrs">Comma-separated list of attribute names whose data are to be included in the response. The attributes are retrieved in the order specified by this parameter. If this parameter is not included, the attributes are retrieved in arbitrary order. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. (optional)</param>
        /// <param name="metadata">A list of metadata names to include in the response. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. (optional)</param>
        /// <param name="orderBy">Criteria for ordering results. See \&quot;Ordering Results\&quot; section for details. (optional)</param>
        /// <param name="options">Options dictionary (optional)</param>
        /// <returns>ApiResponse of List&lt;ListEntitiesResponse&gt;</returns>
        ApiResponse<List<ListEntitiesResponse>> ListEntitiesWithHttpInfo(string id = null, string type = null,
            string idPattern = null, string typePattern = null, string q = null, string mq = null, string georel = null,
            string geometry = null, string coords = null, double? limit = null, double? offset = null,
            string attrs = null, string metadata = null, string orderBy = null, string options = null);

        /// <summary>
        /// Remove Entity
        /// </summary>
        /// <remarks>
        /// Delete the entity. Response: * Successful operation uses 204 No Content * Errors use a non-2xx and (optionally) an error payload. See subsection on \&quot;Error Responses\&quot; for   more details.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityId">Id of the entity to be deleted</param>
        /// <param name="type">Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)</param>
        /// <returns></returns>
        void RemoveEntity(string entityId, string type = null);

        /// <summary>
        /// Remove Entity
        /// </summary>
        /// <remarks>
        /// Delete the entity. Response: * Successful operation uses 204 No Content * Errors use a non-2xx and (optionally) an error payload. See subsection on \&quot;Error Responses\&quot; for   more details.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityId">Id of the entity to be deleted</param>
        /// <param name="type">Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RemoveEntityWithHttpInfo(string entityId, string type = null);

        /// <summary>
        /// Replace all entity attributes
        /// </summary>
        /// <remarks>
        /// The request payload is an object representing the new entity attributes. The object follows the JSON entity representation format (described in a \&quot;JSON Entity Representation\&quot; above), except that &#x60;id&#x60; and &#x60;type&#x60; are not allowed. The attributes previously existing in the entity are removed and replaced by the ones in the request. Response: * Successful operation uses 204 No Content * Errors use a non-2xx and (optionally) an error payload. See subsection on \&quot;Error Responses\&quot; for   more details.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"></param>
        /// <param name="contentType"></param>
        /// <param name="entityId">Id of the entity in question.</param>
        /// <param name="type">Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)</param>
        /// <param name="options">Operations options (optional)</param>
        /// <returns></returns>
        void ReplaceAllEntityAttributes(ReplaceAllEntityAttributesRequest body, string contentType, string entityId,
            string type = null, string options = null);

        /// <summary>
        /// Replace all entity attributes
        /// </summary>
        /// <remarks>
        /// The request payload is an object representing the new entity attributes. The object follows the JSON entity representation format (described in a \&quot;JSON Entity Representation\&quot; above), except that &#x60;id&#x60; and &#x60;type&#x60; are not allowed. The attributes previously existing in the entity are removed and replaced by the ones in the request. Response: * Successful operation uses 204 No Content * Errors use a non-2xx and (optionally) an error payload. See subsection on \&quot;Error Responses\&quot; for   more details.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"></param>
        /// <param name="contentType"></param>
        /// <param name="entityId">Id of the entity in question.</param>
        /// <param name="type">Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)</param>
        /// <param name="options">Operations options (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> ReplaceAllEntityAttributesWithHttpInfo(ReplaceAllEntityAttributesRequest body,
            string contentType, string entityId, string type = null, string options = null);

        /// <summary>
        /// Retrieve Entity
        /// </summary>
        /// <remarks>
        /// The response is an object representing the entity identified by the ID. The object follows the JSON entity representation format (described in \&quot;JSON Entity Representation\&quot; section). This operation must return one entity element only, but there may be more than one entity with the same ID (e.g. entities with same ID but different types). In such case, an error message is returned, with the HTTP status code set to 409 Conflict. Response: * Successful operation uses 200 OK * Errors use a non-2xx and (optionally) an error payload. See subsection on \&quot;Error Responses\&quot; for more details.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityId">Id of the entity to be retrieved</param>
        /// <param name="type">Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)</param>
        /// <param name="attrs">Comma-separated list of attribute names whose data must be included in the response. The attributes are retrieved in the order specified by this parameter. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. If this parameter is not included, the attributes are retrieved in arbitrary order, and all the attributes of the entity are included in the response. (optional)</param>
        /// <param name="metadata">A list of metadata names to include in the response. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. (optional)</param>
        /// <param name="options">Options dictionary (optional)</param>
        /// <returns>RetrieveEntityResponse</returns>
        RetrieveBedEntityResponse RetrieveEntity(string entityId, string type = null, string attrs = null,
            string metadata = null, string options = null);

        /// <summary>
        /// Retrieve Entity
        /// </summary>
        /// <remarks>
        /// The response is an object representing the entity identified by the ID. The object follows the JSON entity representation format (described in \&quot;JSON Entity Representation\&quot; section). This operation must return one entity element only, but there may be more than one entity with the same ID (e.g. entities with same ID but different types). In such case, an error message is returned, with the HTTP status code set to 409 Conflict. Response: * Successful operation uses 200 OK * Errors use a non-2xx and (optionally) an error payload. See subsection on \&quot;Error Responses\&quot; for more details.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityId">Id of the entity to be retrieved</param>
        /// <param name="type">Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)</param>
        /// <param name="attrs">Comma-separated list of attribute names whose data must be included in the response. The attributes are retrieved in the order specified by this parameter. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. If this parameter is not included, the attributes are retrieved in arbitrary order, and all the attributes of the entity are included in the response. (optional)</param>
        /// <param name="metadata">A list of metadata names to include in the response. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. (optional)</param>
        /// <param name="options">Options dictionary (optional)</param>
        /// <returns>ApiResponse of RetrieveEntityResponse</returns>
        ApiResponse<RetrieveBedEntityResponse> RetrieveEntityWithHttpInfo(string entityId, string type = null,
            string attrs = null, string metadata = null, string options = null);

        /// <summary>
        /// Retrieve Entity Attributes
        /// </summary>
        /// <remarks>
        /// This request is similar to retreiving the whole entity, however this one omits the &#x60;id&#x60; and &#x60;type&#x60; fields. Just like the general request of getting an entire entity, this operation must return only one entity element. If more than one entity with the same ID is found (e.g. entities with same ID but different type), an error message is returned, with the HTTP status code set to 409 Conflict. Response: * Successful operation uses 200 OK * Errors use a non-2xx and (optionally) an error payload. See subsection on \&quot;Error Responses\&quot; for   more details.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityId">Id of the entity to be retrieved</param>
        /// <param name="type">Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)</param>
        /// <param name="attrs">Comma-separated list of attribute names whose data are to be included in the response. The attributes are retrieved in the order specified by this parameter. If this parameter is not included, the attributes are retrieved in arbitrary order, and all the attributes of the entity are included in the response. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. (optional)</param>
        /// <param name="metadata">A list of metadata names to include in the response. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. (optional)</param>
        /// <param name="options">Options dictionary (optional)</param>
        /// <returns>RetrieveEntityAttributesResponse</returns>
        RetrieveEntityAttributesResponse RetrieveEntityAttributes(string entityId, string type = null,
            string attrs = null, string metadata = null, string options = null);

        /// <summary>
        /// Retrieve Entity Attributes
        /// </summary>
        /// <remarks>
        /// This request is similar to retreiving the whole entity, however this one omits the &#x60;id&#x60; and &#x60;type&#x60; fields. Just like the general request of getting an entire entity, this operation must return only one entity element. If more than one entity with the same ID is found (e.g. entities with same ID but different type), an error message is returned, with the HTTP status code set to 409 Conflict. Response: * Successful operation uses 200 OK * Errors use a non-2xx and (optionally) an error payload. See subsection on \&quot;Error Responses\&quot; for   more details.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityId">Id of the entity to be retrieved</param>
        /// <param name="type">Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)</param>
        /// <param name="attrs">Comma-separated list of attribute names whose data are to be included in the response. The attributes are retrieved in the order specified by this parameter. If this parameter is not included, the attributes are retrieved in arbitrary order, and all the attributes of the entity are included in the response. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. (optional)</param>
        /// <param name="metadata">A list of metadata names to include in the response. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. (optional)</param>
        /// <param name="options">Options dictionary (optional)</param>
        /// <returns>ApiResponse of RetrieveEntityAttributesResponse</returns>
        ApiResponse<RetrieveEntityAttributesResponse> RetrieveEntityAttributesWithHttpInfo(string entityId,
            string type = null, string attrs = null, string metadata = null, string options = null);

        /// <summary>
        /// Update Existing Entity Attributes
        /// </summary>
        /// <remarks>
        /// The request payload is an object representing the attributes to update. The object follows the JSON entity representation format (described in \&quot;JSON Entity Representation\&quot; section), except that &#x60;id&#x60; and &#x60;type&#x60; are not allowed. The entity attributes are updated with the ones in the payload. In addition to that, if one or more attributes in the payload doesn&#x27;t exist in the entity, an error is returned. Response: * Successful operation uses 204 No Content * Errors use a non-2xx and (optionally) an error payload. See subsection on \&quot;Error Responses\&quot; for   more details.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"></param>
        /// <param name="contentType"></param>
        /// <param name="entityId">Id of the entity to be updated</param>
        /// <param name="type">Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)</param>
        /// <param name="options">Operations options (optional)</param>
        /// <returns></returns>
        void UpdateExistingEntityAttributes(UpdateExistingEntityAttributesRequest body, string contentType,
            string entityId, string type = null, string options = null);

        /// <summary>
        /// Update Existing Entity Attributes
        /// </summary>
        /// <remarks>
        /// The request payload is an object representing the attributes to update. The object follows the JSON entity representation format (described in \&quot;JSON Entity Representation\&quot; section), except that &#x60;id&#x60; and &#x60;type&#x60; are not allowed. The entity attributes are updated with the ones in the payload. In addition to that, if one or more attributes in the payload doesn&#x27;t exist in the entity, an error is returned. Response: * Successful operation uses 204 No Content * Errors use a non-2xx and (optionally) an error payload. See subsection on \&quot;Error Responses\&quot; for   more details.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"></param>
        /// <param name="contentType"></param>
        /// <param name="entityId">Id of the entity to be updated</param>
        /// <param name="type">Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)</param>
        /// <param name="options">Operations options (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateExistingEntityAttributesWithHttpInfo(UpdateExistingEntityAttributesRequest body,
            string contentType, string entityId, string type = null, string options = null);

        /// <summary>
        /// Update or Append Entity Attributes
        /// </summary>
        /// <remarks>
        /// The request payload is an object representing the attributes to append or update. The object follows the JSON entity representation format (described in \&quot;JSON Entity Representation\&quot; section), except that &#x60;id&#x60; and &#x60;type&#x60; are not allowed. The entity attributes are updated with the ones in the payload, depending on whether the &#x60;append&#x60; operation option is used or not. * If &#x60;append&#x60; is not used: the entity attributes are updated (if they previously exist) or appended   (if they don&#x27;t previously exist) with the ones in the payload. * If &#x60;append&#x60; is used (i.e. strict append semantics): all the attributes in the payload not   previously existing in the entity are appended. In addition to that, in case some of the   attributes in the payload already exist in the entity, an error is returned. Response: * Successful operation uses 204 No Content * Errors use a non-2xx and (optionally) an error payload. See subsection on \&quot;Error Responses\&quot; for   more details.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"></param>
        /// <param name="contentType"></param>
        /// <param name="entityId">Entity id to be updated</param>
        /// <param name="type">Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)</param>
        /// <param name="options">Operations options (optional)</param>
        /// <returns></returns>
        void UpdateOrAppendEntityAttributes(UpdateOrAppendEntityAttributesRequest body, string contentType,
            string entityId, string type = null, string options = null);

        /// <summary>
        /// Update or Append Entity Attributes
        /// </summary>
        /// <remarks>
        /// The request payload is an object representing the attributes to append or update. The object follows the JSON entity representation format (described in \&quot;JSON Entity Representation\&quot; section), except that &#x60;id&#x60; and &#x60;type&#x60; are not allowed. The entity attributes are updated with the ones in the payload, depending on whether the &#x60;append&#x60; operation option is used or not. * If &#x60;append&#x60; is not used: the entity attributes are updated (if they previously exist) or appended   (if they don&#x27;t previously exist) with the ones in the payload. * If &#x60;append&#x60; is used (i.e. strict append semantics): all the attributes in the payload not   previously existing in the entity are appended. In addition to that, in case some of the   attributes in the payload already exist in the entity, an error is returned. Response: * Successful operation uses 204 No Content * Errors use a non-2xx and (optionally) an error payload. See subsection on \&quot;Error Responses\&quot; for   more details.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"></param>
        /// <param name="contentType"></param>
        /// <param name="entityId">Entity id to be updated</param>
        /// <param name="type">Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)</param>
        /// <param name="options">Operations options (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateOrAppendEntityAttributesWithHttpInfo(UpdateOrAppendEntityAttributesRequest body,
            string contentType, string entityId, string type = null, string options = null);

        #endregion Synchronous Operations

        #region Asynchronous Operations

        /// <summary>
        /// Create Entity
        /// </summary>
        /// <remarks>
        /// The payload is an object representing the entity to be created. The object follows the JSON entity representation format (described in a \&quot;JSON Entity Representation\&quot; section). Response: * Successful operation uses 201 Created (if upsert option is not used) or 204 No Content (if   upsert option is used). Response includes a &#x60;Location&#x60; header with the URL of the   created entity. * Errors use a non-2xx and (optionally) an error payload. See subsection on \&quot;Error Responses\&quot; for   more details.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"></param>
        /// <param name="contentType"></param>
        /// <param name="options">Options dictionary (optional)</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task CreateEntityAsync(CreateEntityRequest body, string contentType,
            string options = null);

        /// <summary>
        /// Create Entity
        /// </summary>
        /// <remarks>
        /// The payload is an object representing the entity to be created. The object follows the JSON entity representation format (described in a \&quot;JSON Entity Representation\&quot; section). Response: * Successful operation uses 201 Created (if upsert option is not used) or 204 No Content (if   upsert option is used). Response includes a &#x60;Location&#x60; header with the URL of the   created entity. * Errors use a non-2xx and (optionally) an error payload. See subsection on \&quot;Error Responses\&quot; for   more details.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"></param>
        /// <param name="contentType"></param>
        /// <param name="options">Options dictionary (optional)</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> CreateEntityAsyncWithHttpInfo(CreateEntityRequest body,
            string contentType, string options = null);

        /// <summary>
        /// List Entities
        /// </summary>
        /// <remarks>
        /// Retrieves a list of entities that match different criteria by id, type, pattern matching (either id or type) and/or those which match a query or geographical query (see [Simple Query Language](#simple_query_language) and  [Geographical Queries](#geographical_queries)). A given entity has to match all the criteria to be retrieved (i.e., the criteria is combined in a logical AND way). Note that pattern matching query parameters are incompatible (i.e. mutually exclusive) with their corresponding exact matching parameters, i.e. &#x60;idPattern&#x60; with &#x60;id&#x60; and &#x60;typePattern&#x60; with &#x60;type&#x60;. The response payload is an array containing one object per matching entity. Each entity follows the JSON entity representation format (described in \&quot;JSON Entity Representation\&quot; section). Response code: * Successful operation uses 200 OK * Errors use a non-2xx and (optionally) an error payload. See subsection on \&quot;Error Responses\&quot; for   more details.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A comma-separated list of elements. Retrieve entities whose ID matches one of the elements in the list. Incompatible with &#x60;idPattern&#x60;. (optional)</param>
        /// <param name="type">comma-separated list of elements. Retrieve entities whose type matches one of the elements in the list. Incompatible with &#x60;typePattern&#x60;. (optional)</param>
        /// <param name="idPattern">A correctly formated regular expression. Retrieve entities whose ID matches the regular expression. Incompatible with &#x60;id&#x60;. (optional)</param>
        /// <param name="typePattern">A correctly formated regular expression. Retrieve entities whose type matches the regular expression. Incompatible with &#x60;type&#x60;. (optional)</param>
        /// <param name="q">A query expression, composed of a list of statements separated by &#x60;;&#x60;, i.e., q&#x3D;statement1;statement2;statement3. See [Simple Query Language specification](#simple_query_language). (optional)</param>
        /// <param name="mq">A query expression for attribute metadata, composed of a list of statements separated by &#x60;;&#x60;, i.e., mq&#x3D;statement1;statement2;statement3. See [Simple Query Language specification](#simple_query_language). (optional)</param>
        /// <param name="georel">Spatial relationship between matching entities and a reference shape. See [Geographical Queries](#geographical_queries). (optional)</param>
        /// <param name="geometry">Geografical area to which the query is restricted. See [Geographical Queries](#geographical_queries). (optional)</param>
        /// <param name="coords">List of latitude-longitude pairs of coordinates separated by &#x27;;&#x27;. See [Geographical Queries](#geographical_queries). (optional)</param>
        /// <param name="limit">Limits the number of entities to be retrieved (optional)</param>
        /// <param name="offset">Establishes the offset from where entities are retrieved (optional)</param>
        /// <param name="attrs">Comma-separated list of attribute names whose data are to be included in the response. The attributes are retrieved in the order specified by this parameter. If this parameter is not included, the attributes are retrieved in arbitrary order. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. (optional)</param>
        /// <param name="metadata">A list of metadata names to include in the response. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. (optional)</param>
        /// <param name="orderBy">Criteria for ordering results. See \&quot;Ordering Results\&quot; section for details. (optional)</param>
        /// <param name="options">Options dictionary (optional)</param>
        /// <returns>Task of List&lt;ListEntitiesResponse&gt;</returns>
        System.Threading.Tasks.Task<List<ListEntitiesResponse>> ListEntitiesAsync(string id = null,
            string type = null,
            string idPattern = null, string typePattern = null, string q = null, string mq = null, string georel = null,
            string geometry = null, string coords = null, double? limit = null, double? offset = null,
            string attrs = null, string metadata = null, string orderBy = null, string options = null);

        /// <summary>
        /// List Entities
        /// </summary>
        /// <remarks>
        /// Retrieves a list of entities that match different criteria by id, type, pattern matching (either id or type) and/or those which match a query or geographical query (see [Simple Query Language](#simple_query_language) and  [Geographical Queries](#geographical_queries)). A given entity has to match all the criteria to be retrieved (i.e., the criteria is combined in a logical AND way). Note that pattern matching query parameters are incompatible (i.e. mutually exclusive) with their corresponding exact matching parameters, i.e. &#x60;idPattern&#x60; with &#x60;id&#x60; and &#x60;typePattern&#x60; with &#x60;type&#x60;. The response payload is an array containing one object per matching entity. Each entity follows the JSON entity representation format (described in \&quot;JSON Entity Representation\&quot; section). Response code: * Successful operation uses 200 OK * Errors use a non-2xx and (optionally) an error payload. See subsection on \&quot;Error Responses\&quot; for   more details.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A comma-separated list of elements. Retrieve entities whose ID matches one of the elements in the list. Incompatible with &#x60;idPattern&#x60;. (optional)</param>
        /// <param name="type">comma-separated list of elements. Retrieve entities whose type matches one of the elements in the list. Incompatible with &#x60;typePattern&#x60;. (optional)</param>
        /// <param name="idPattern">A correctly formated regular expression. Retrieve entities whose ID matches the regular expression. Incompatible with &#x60;id&#x60;. (optional)</param>
        /// <param name="typePattern">A correctly formated regular expression. Retrieve entities whose type matches the regular expression. Incompatible with &#x60;type&#x60;. (optional)</param>
        /// <param name="q">A query expression, composed of a list of statements separated by &#x60;;&#x60;, i.e., q&#x3D;statement1;statement2;statement3. See [Simple Query Language specification](#simple_query_language). (optional)</param>
        /// <param name="mq">A query expression for attribute metadata, composed of a list of statements separated by &#x60;;&#x60;, i.e., mq&#x3D;statement1;statement2;statement3. See [Simple Query Language specification](#simple_query_language). (optional)</param>
        /// <param name="georel">Spatial relationship between matching entities and a reference shape. See [Geographical Queries](#geographical_queries). (optional)</param>
        /// <param name="geometry">Geografical area to which the query is restricted. See [Geographical Queries](#geographical_queries). (optional)</param>
        /// <param name="coords">List of latitude-longitude pairs of coordinates separated by &#x27;;&#x27;. See [Geographical Queries](#geographical_queries). (optional)</param>
        /// <param name="limit">Limits the number of entities to be retrieved (optional)</param>
        /// <param name="offset">Establishes the offset from where entities are retrieved (optional)</param>
        /// <param name="attrs">Comma-separated list of attribute names whose data are to be included in the response. The attributes are retrieved in the order specified by this parameter. If this parameter is not included, the attributes are retrieved in arbitrary order. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. (optional)</param>
        /// <param name="metadata">A list of metadata names to include in the response. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. (optional)</param>
        /// <param name="orderBy">Criteria for ordering results. See \&quot;Ordering Results\&quot; section for details. (optional)</param>
        /// <param name="options">Options dictionary (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;ListEntitiesResponse&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<ListEntitiesResponse>>> ListEntitiesAsyncWithHttpInfo(
            string id = null, string type = null, string idPattern = null, string typePattern = null, string q = null,
            string mq = null, string georel = null, string geometry = null, string coords = null, double? limit = null,
            double? offset = null, string attrs = null, string metadata = null, string orderBy = null,
            string options = null);

        /// <summary>
        /// Remove Entity
        /// </summary>
        /// <remarks>
        /// Delete the entity. Response: * Successful operation uses 204 No Content * Errors use a non-2xx and (optionally) an error payload. See subsection on \&quot;Error Responses\&quot; for   more details.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityId">Id of the entity to be deleted</param>
        /// <param name="type">Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RemoveEntityAsync(string entityId, string type = null);

        /// <summary>
        /// Remove Entity
        /// </summary>
        /// <remarks>
        /// Delete the entity. Response: * Successful operation uses 204 No Content * Errors use a non-2xx and (optionally) an error payload. See subsection on \&quot;Error Responses\&quot; for   more details.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityId">Id of the entity to be deleted</param>
        /// <param name="type">Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RemoveEntityAsyncWithHttpInfo(string entityId,
            string type = null);

        /// <summary>
        /// Replace all entity attributes
        /// </summary>
        /// <remarks>
        /// The request payload is an object representing the new entity attributes. The object follows the JSON entity representation format (described in a \&quot;JSON Entity Representation\&quot; above), except that &#x60;id&#x60; and &#x60;type&#x60; are not allowed. The attributes previously existing in the entity are removed and replaced by the ones in the request. Response: * Successful operation uses 204 No Content * Errors use a non-2xx and (optionally) an error payload. See subsection on \&quot;Error Responses\&quot; for   more details.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"></param>
        /// <param name="contentType"></param>
        /// <param name="entityId">Id of the entity in question.</param>
        /// <param name="type">Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)</param>
        /// <param name="options">Operations options (optional)</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task ReplaceAllEntityAttributesAsync(ReplaceAllEntityAttributesRequest body,
            string contentType, string entityId, string type = null, string options = null);

        /// <summary>
        /// Replace all entity attributes
        /// </summary>
        /// <remarks>
        /// The request payload is an object representing the new entity attributes. The object follows the JSON entity representation format (described in a \&quot;JSON Entity Representation\&quot; above), except that &#x60;id&#x60; and &#x60;type&#x60; are not allowed. The attributes previously existing in the entity are removed and replaced by the ones in the request. Response: * Successful operation uses 204 No Content * Errors use a non-2xx and (optionally) an error payload. See subsection on \&quot;Error Responses\&quot; for   more details.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"></param>
        /// <param name="contentType"></param>
        /// <param name="entityId">Id of the entity in question.</param>
        /// <param name="type">Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)</param>
        /// <param name="options">Operations options (optional)</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> ReplaceAllEntityAttributesAsyncWithHttpInfo(
            ReplaceAllEntityAttributesRequest body, string contentType, string entityId, string type = null,
            string options = null);

        /// <summary>
        /// Retrieve Entity
        /// </summary>
        /// <remarks>
        /// The response is an object representing the entity identified by the ID. The object follows the JSON entity representation format (described in \&quot;JSON Entity Representation\&quot; section). This operation must return one entity element only, but there may be more than one entity with the same ID (e.g. entities with same ID but different types). In such case, an error message is returned, with the HTTP status code set to 409 Conflict. Response: * Successful operation uses 200 OK * Errors use a non-2xx and (optionally) an error payload. See subsection on \&quot;Error Responses\&quot; for more details.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityId">Id of the entity to be retrieved</param>
        /// <param name="type">Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)</param>
        /// <param name="attrs">Comma-separated list of attribute names whose data must be included in the response. The attributes are retrieved in the order specified by this parameter. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. If this parameter is not included, the attributes are retrieved in arbitrary order, and all the attributes of the entity are included in the response. (optional)</param>
        /// <param name="metadata">A list of metadata names to include in the response. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. (optional)</param>
        /// <param name="options">Options dictionary (optional)</param>
        /// <returns>Task of RetrieveEntityResponse</returns>
        System.Threading.Tasks.Task<RetrieveBedEntityResponse> RetrieveBedEntityAsync(string entityId, string type = null,
            string attrs = null, string metadata = null, string options = null);

        /// <summary>
        /// Retrieve Entity
        /// </summary>
        /// <remarks>
        /// The response is an object representing the entity identified by the ID. The object follows the JSON entity representation format (described in \&quot;JSON Entity Representation\&quot; section). This operation must return one entity element only, but there may be more than one entity with the same ID (e.g. entities with same ID but different types). In such case, an error message is returned, with the HTTP status code set to 409 Conflict. Response: * Successful operation uses 200 OK * Errors use a non-2xx and (optionally) an error payload. See subsection on \&quot;Error Responses\&quot; for more details.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityId">Id of the entity to be retrieved</param>
        /// <param name="type">Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)</param>
        /// <param name="attrs">Comma-separated list of attribute names whose data must be included in the response. The attributes are retrieved in the order specified by this parameter. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. If this parameter is not included, the attributes are retrieved in arbitrary order, and all the attributes of the entity are included in the response. (optional)</param>
        /// <param name="metadata">A list of metadata names to include in the response. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. (optional)</param>
        /// <param name="options">Options dictionary (optional)</param>
        /// <returns>Task of ApiResponse (RetrieveEntityResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<RetrieveBedEntityResponse>> RetrieveEntityAsyncWithHttpInfo(
            string entityId, string type = null, string attrs = null, string metadata = null, string options = null);

        /// <summary>
        /// Retrieve Entity Attributes
        /// </summary>
        /// <remarks>
        /// This request is similar to retreiving the whole entity, however this one omits the &#x60;id&#x60; and &#x60;type&#x60; fields. Just like the general request of getting an entire entity, this operation must return only one entity element. If more than one entity with the same ID is found (e.g. entities with same ID but different type), an error message is returned, with the HTTP status code set to 409 Conflict. Response: * Successful operation uses 200 OK * Errors use a non-2xx and (optionally) an error payload. See subsection on \&quot;Error Responses\&quot; for   more details.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityId">Id of the entity to be retrieved</param>
        /// <param name="type">Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)</param>
        /// <param name="attrs">Comma-separated list of attribute names whose data are to be included in the response. The attributes are retrieved in the order specified by this parameter. If this parameter is not included, the attributes are retrieved in arbitrary order, and all the attributes of the entity are included in the response. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. (optional)</param>
        /// <param name="metadata">A list of metadata names to include in the response. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. (optional)</param>
        /// <param name="options">Options dictionary (optional)</param>
        /// <returns>Task of RetrieveEntityAttributesResponse</returns>
        System.Threading.Tasks.Task<RetrieveEntityAttributesResponse> RetrieveEntityAttributesAsync(string entityId,
            string type = null, string attrs = null, string metadata = null, string options = null);

        /// <summary>
        /// Retrieve Entity Attributes
        /// </summary>
        /// <remarks>
        /// This request is similar to retreiving the whole entity, however this one omits the &#x60;id&#x60; and &#x60;type&#x60; fields. Just like the general request of getting an entire entity, this operation must return only one entity element. If more than one entity with the same ID is found (e.g. entities with same ID but different type), an error message is returned, with the HTTP status code set to 409 Conflict. Response: * Successful operation uses 200 OK * Errors use a non-2xx and (optionally) an error payload. See subsection on \&quot;Error Responses\&quot; for   more details.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityId">Id of the entity to be retrieved</param>
        /// <param name="type">Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)</param>
        /// <param name="attrs">Comma-separated list of attribute names whose data are to be included in the response. The attributes are retrieved in the order specified by this parameter. If this parameter is not included, the attributes are retrieved in arbitrary order, and all the attributes of the entity are included in the response. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. (optional)</param>
        /// <param name="metadata">A list of metadata names to include in the response. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. (optional)</param>
        /// <param name="options">Options dictionary (optional)</param>
        /// <returns>Task of ApiResponse (RetrieveEntityAttributesResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<RetrieveEntityAttributesResponse>>
            RetrieveEntityAttributesAsyncWithHttpInfo(string entityId, string type = null, string attrs = null,
                string metadata = null, string options = null);

        /// <summary>
        /// Update Existing Entity Attributes
        /// </summary>
        /// <remarks>
        /// The request payload is an object representing the attributes to update. The object follows the JSON entity representation format (described in \&quot;JSON Entity Representation\&quot; section), except that &#x60;id&#x60; and &#x60;type&#x60; are not allowed. The entity attributes are updated with the ones in the payload. In addition to that, if one or more attributes in the payload doesn&#x27;t exist in the entity, an error is returned. Response: * Successful operation uses 204 No Content * Errors use a non-2xx and (optionally) an error payload. See subsection on \&quot;Error Responses\&quot; for   more details.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"></param>
        /// <param name="contentType"></param>
        /// <param name="entityId">Id of the entity to be updated</param>
        /// <param name="type">Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)</param>
        /// <param name="options">Operations options (optional)</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task UpdateExistingEntityAttributesAsync(UpdateExistingEntityAttributesRequest body,
            string contentType, string entityId, string type = null, string options = null);

        /// <summary>
        /// Update Existing Entity Attributes
        /// </summary>
        /// <remarks>
        /// The request payload is an object representing the attributes to update. The object follows the JSON entity representation format (described in \&quot;JSON Entity Representation\&quot; section), except that &#x60;id&#x60; and &#x60;type&#x60; are not allowed. The entity attributes are updated with the ones in the payload. In addition to that, if one or more attributes in the payload doesn&#x27;t exist in the entity, an error is returned. Response: * Successful operation uses 204 No Content * Errors use a non-2xx and (optionally) an error payload. See subsection on \&quot;Error Responses\&quot; for   more details.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"></param>
        /// <param name="contentType"></param>
        /// <param name="entityId">Id of the entity to be updated</param>
        /// <param name="type">Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)</param>
        /// <param name="options">Operations options (optional)</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> UpdateExistingEntityAttributesAsyncWithHttpInfo(
            UpdateExistingEntityAttributesRequest body, string contentType, string entityId, string type = null,
            string options = null);

        /// <summary>
        /// Update or Append Entity Attributes
        /// </summary>
        /// <remarks>
        /// The request payload is an object representing the attributes to append or update. The object follows the JSON entity representation format (described in \&quot;JSON Entity Representation\&quot; section), except that &#x60;id&#x60; and &#x60;type&#x60; are not allowed. The entity attributes are updated with the ones in the payload, depending on whether the &#x60;append&#x60; operation option is used or not. * If &#x60;append&#x60; is not used: the entity attributes are updated (if they previously exist) or appended   (if they don&#x27;t previously exist) with the ones in the payload. * If &#x60;append&#x60; is used (i.e. strict append semantics): all the attributes in the payload not   previously existing in the entity are appended. In addition to that, in case some of the   attributes in the payload already exist in the entity, an error is returned. Response: * Successful operation uses 204 No Content * Errors use a non-2xx and (optionally) an error payload. See subsection on \&quot;Error Responses\&quot; for   more details.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"></param>
        /// <param name="contentType"></param>
        /// <param name="entityId">Entity id to be updated</param>
        /// <param name="type">Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)</param>
        /// <param name="options">Operations options (optional)</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task UpdateOrAppendEntityAttributesAsync(UpdateOrAppendEntityAttributesRequest body,
            string contentType, string entityId, string type = null, string options = null);

        /// <summary>
        /// Update or Append Entity Attributes
        /// </summary>
        /// <remarks>
        /// The request payload is an object representing the attributes to append or update. The object follows the JSON entity representation format (described in \&quot;JSON Entity Representation\&quot; section), except that &#x60;id&#x60; and &#x60;type&#x60; are not allowed. The entity attributes are updated with the ones in the payload, depending on whether the &#x60;append&#x60; operation option is used or not. * If &#x60;append&#x60; is not used: the entity attributes are updated (if they previously exist) or appended   (if they don&#x27;t previously exist) with the ones in the payload. * If &#x60;append&#x60; is used (i.e. strict append semantics): all the attributes in the payload not   previously existing in the entity are appended. In addition to that, in case some of the   attributes in the payload already exist in the entity, an error is returned. Response: * Successful operation uses 204 No Content * Errors use a non-2xx and (optionally) an error payload. See subsection on \&quot;Error Responses\&quot; for   more details.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"></param>
        /// <param name="contentType"></param>
        /// <param name="entityId">Entity id to be updated</param>
        /// <param name="type">Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)</param>
        /// <param name="options">Operations options (optional)</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> UpdateOrAppendEntityAttributesAsyncWithHttpInfo(
            UpdateOrAppendEntityAttributesRequest body, string contentType, string entityId, string type = null,
            string options = null);

        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class EntitiesApi : IEntitiesApi
    {
        private ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="EntitiesApi"/> class.
        /// </summary>
        /// <returns></returns>
        public EntitiesApi(String basePath)
        {
            this.Configuration = new Configuration {BasePath = basePath};

            ExceptionFactory = Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="EntitiesApi"/> class
        /// </summary>
        /// <returns></returns>
        public EntitiesApi()
        {
            this.Configuration = Configuration.Default;

            ExceptionFactory = Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="EntitiesApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public EntitiesApi(Configuration configuration = null)
        {
            if (configuration == null) // use the default one in Configuration
                this.Configuration = Configuration.Default;
            else
                this.Configuration = configuration;

            ExceptionFactory = Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public String GetBasePath()
        {
            return this.Configuration.ApiClient.RestClient.BaseUrl.ToString();
        }

        /// <summary>
        /// Sets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        [Obsolete(
            "SetBasePath is deprecated, please do 'Configuration.ApiClient = new ApiClient(\"http://new-path\")' instead.")]
        public void SetBasePath(String basePath)
        {
            // do nothing
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public Configuration Configuration { get; set; }

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }

                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Gets the default header.
        /// </summary>
        /// <returns>Dictionary of HTTP header</returns>
        [Obsolete("DefaultHeader is deprecated, please use Configuration.DefaultHeader instead.")]
        public IDictionary<String, String> DefaultHeader()
        {
            return new ReadOnlyDictionary<string, string>(this.Configuration.DefaultHeader);
        }

        /// <summary>
        /// Add default header.
        /// </summary>
        /// <param name="key">Header field name.</param>
        /// <param name="value">Header field value.</param>
        /// <returns></returns>
        [Obsolete("AddDefaultHeader is deprecated, please use Configuration.AddDefaultHeader instead.")]
        public void AddDefaultHeader(string key, string value)
        {
            this.Configuration.AddDefaultHeader(key, value);
        }

        /// <summary>
        /// Create Entity The payload is an object representing the entity to be created. The object follows the JSON entity representation format (described in a \&quot;JSON Entity Representation\&quot; section). Response: * Successful operation uses 201 Created (if upsert option is not used) or 204 No Content (if   upsert option is used). Response includes a &#x60;Location&#x60; header with the URL of the   created entity. * Errors use a non-2xx and (optionally) an error payload. See subsection on \&quot;Error Responses\&quot; for   more details.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"></param>
        /// <param name="contentType"></param>
        /// <param name="options">Options dictionary (optional)</param>
        /// <returns></returns>
        public void CreateEntity(CreateEntityRequest body, string contentType, string options = null)
        {
            CreateEntityWithHttpInfo(body, contentType, options);
        }

        /// <summary>
        /// Create Entity The payload is an object representing the entity to be created. The object follows the JSON entity representation format (described in a \&quot;JSON Entity Representation\&quot; section). Response: * Successful operation uses 201 Created (if upsert option is not used) or 204 No Content (if   upsert option is used). Response includes a &#x60;Location&#x60; header with the URL of the   created entity. * Errors use a non-2xx and (optionally) an error payload. See subsection on \&quot;Error Responses\&quot; for   more details.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"></param>
        /// <param name="contentType"></param>
        /// <param name="options">Options dictionary (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> CreateEntityWithHttpInfo(CreateEntityRequest body, string contentType,
            string options = null)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling EntitiesApi->CreateEntity");
            // verify the required parameter 'contentType' is set
            if (contentType == null)
                throw new ApiException(400,
                    "Missing required parameter 'contentType' when calling EntitiesApi->CreateEntity");

            var localVarPath = "/v2/entities";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[]
            {
                "application/json"
            };
            String localVarHttpContentType =
                this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[]
            {
            };
            String localVarHttpHeaderAccept =
                this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (options != null)
                localVarQueryParams.AddRange(
                    this.Configuration.ApiClient.ParameterToKeyValuePairs("", "options", options)); // query parameter
            if (contentType != null)
                localVarHeaderParams.Add("Content-Type",
                    this.Configuration.ApiClient.ParameterToString(contentType)); // header parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams,
                localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateEntity", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Create Entity The payload is an object representing the entity to be created. The object follows the JSON entity representation format (described in a \&quot;JSON Entity Representation\&quot; section). Response: * Successful operation uses 201 Created (if upsert option is not used) or 204 No Content (if   upsert option is used). Response includes a &#x60;Location&#x60; header with the URL of the   created entity. * Errors use a non-2xx and (optionally) an error payload. See subsection on \&quot;Error Responses\&quot; for   more details.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"></param>
        /// <param name="contentType"></param>
        /// <param name="options">Options dictionary (optional)</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task CreateEntityAsync(CreateEntityRequest body, string contentType,
            string options = null)
        {
            await CreateEntityAsyncWithHttpInfo(body, contentType, options);
        }

        /// <summary>
        /// Create Entity The payload is an object representing the entity to be created. The object follows the JSON entity representation format (described in a \&quot;JSON Entity Representation\&quot; section). Response: * Successful operation uses 201 Created (if upsert option is not used) or 204 No Content (if   upsert option is used). Response includes a &#x60;Location&#x60; header with the URL of the   created entity. * Errors use a non-2xx and (optionally) an error payload. See subsection on \&quot;Error Responses\&quot; for   more details.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"></param>
        /// <param name="contentType"></param>
        /// <param name="options">Options dictionary (optional)</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> CreateEntityAsyncWithHttpInfo(
            CreateEntityRequest body, string contentType, string options = null)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling EntitiesApi->CreateEntity");
            // verify the required parameter 'contentType' is set
            if (contentType == null)
                throw new ApiException(400,
                    "Missing required parameter 'contentType' when calling EntitiesApi->CreateEntity");

            var localVarPath = "/v2/entities";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[]
            {
                "application/json"
            };
            String localVarHttpContentType =
                this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[]
            {
            };
            String localVarHttpHeaderAccept =
                this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (options != null)
                localVarQueryParams.AddRange(
                    this.Configuration.ApiClient.ParameterToKeyValuePairs("", "options", options)); // query parameter
            if (contentType != null)
                localVarHeaderParams.Add("Content-Type",
                    this.Configuration.ApiClient.ParameterToString(contentType)); // header parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(
                localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams,
                localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateEntity", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// List Entities Retrieves a list of entities that match different criteria by id, type, pattern matching (either id or type) and/or those which match a query or geographical query (see [Simple Query Language](#simple_query_language) and  [Geographical Queries](#geographical_queries)). A given entity has to match all the criteria to be retrieved (i.e., the criteria is combined in a logical AND way). Note that pattern matching query parameters are incompatible (i.e. mutually exclusive) with their corresponding exact matching parameters, i.e. &#x60;idPattern&#x60; with &#x60;id&#x60; and &#x60;typePattern&#x60; with &#x60;type&#x60;. The response payload is an array containing one object per matching entity. Each entity follows the JSON entity representation format (described in \&quot;JSON Entity Representation\&quot; section). Response code: * Successful operation uses 200 OK * Errors use a non-2xx and (optionally) an error payload. See subsection on \&quot;Error Responses\&quot; for   more details.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A comma-separated list of elements. Retrieve entities whose ID matches one of the elements in the list. Incompatible with &#x60;idPattern&#x60;. (optional)</param>
        /// <param name="type">comma-separated list of elements. Retrieve entities whose type matches one of the elements in the list. Incompatible with &#x60;typePattern&#x60;. (optional)</param>
        /// <param name="idPattern">A correctly formated regular expression. Retrieve entities whose ID matches the regular expression. Incompatible with &#x60;id&#x60;. (optional)</param>
        /// <param name="typePattern">A correctly formated regular expression. Retrieve entities whose type matches the regular expression. Incompatible with &#x60;type&#x60;. (optional)</param>
        /// <param name="q">A query expression, composed of a list of statements separated by &#x60;;&#x60;, i.e., q&#x3D;statement1;statement2;statement3. See [Simple Query Language specification](#simple_query_language). (optional)</param>
        /// <param name="mq">A query expression for attribute metadata, composed of a list of statements separated by &#x60;;&#x60;, i.e., mq&#x3D;statement1;statement2;statement3. See [Simple Query Language specification](#simple_query_language). (optional)</param>
        /// <param name="georel">Spatial relationship between matching entities and a reference shape. See [Geographical Queries](#geographical_queries). (optional)</param>
        /// <param name="geometry">Geografical area to which the query is restricted. See [Geographical Queries](#geographical_queries). (optional)</param>
        /// <param name="coords">List of latitude-longitude pairs of coordinates separated by &#x27;;&#x27;. See [Geographical Queries](#geographical_queries). (optional)</param>
        /// <param name="limit">Limits the number of entities to be retrieved (optional)</param>
        /// <param name="offset">Establishes the offset from where entities are retrieved (optional)</param>
        /// <param name="attrs">Comma-separated list of attribute names whose data are to be included in the response. The attributes are retrieved in the order specified by this parameter. If this parameter is not included, the attributes are retrieved in arbitrary order. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. (optional)</param>
        /// <param name="metadata">A list of metadata names to include in the response. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. (optional)</param>
        /// <param name="orderBy">Criteria for ordering results. See \&quot;Ordering Results\&quot; section for details. (optional)</param>
        /// <param name="options">Options dictionary (optional)</param>
        /// <returns>List&lt;ListEntitiesResponse&gt;</returns>
        public List<ListEntitiesResponse> ListEntities(string id = null, string type = null,
            string idPattern = null, string typePattern = null, string q = null, string mq = null, string georel = null,
            string geometry = null, string coords = null, double? limit = null, double? offset = null,
            string attrs = null, string metadata = null, string orderBy = null, string options = null)
        {
            ApiResponse<List<ListEntitiesResponse>> localVarResponse = ListEntitiesWithHttpInfo(id, type, idPattern,
                typePattern, q, mq, georel, geometry, coords, limit, offset, attrs, metadata, orderBy, options);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List Entities Retrieves a list of entities that match different criteria by id, type, pattern matching (either id or type) and/or those which match a query or geographical query (see [Simple Query Language](#simple_query_language) and  [Geographical Queries](#geographical_queries)). A given entity has to match all the criteria to be retrieved (i.e., the criteria is combined in a logical AND way). Note that pattern matching query parameters are incompatible (i.e. mutually exclusive) with their corresponding exact matching parameters, i.e. &#x60;idPattern&#x60; with &#x60;id&#x60; and &#x60;typePattern&#x60; with &#x60;type&#x60;. The response payload is an array containing one object per matching entity. Each entity follows the JSON entity representation format (described in \&quot;JSON Entity Representation\&quot; section). Response code: * Successful operation uses 200 OK * Errors use a non-2xx and (optionally) an error payload. See subsection on \&quot;Error Responses\&quot; for   more details.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A comma-separated list of elements. Retrieve entities whose ID matches one of the elements in the list. Incompatible with &#x60;idPattern&#x60;. (optional)</param>
        /// <param name="type">comma-separated list of elements. Retrieve entities whose type matches one of the elements in the list. Incompatible with &#x60;typePattern&#x60;. (optional)</param>
        /// <param name="idPattern">A correctly formated regular expression. Retrieve entities whose ID matches the regular expression. Incompatible with &#x60;id&#x60;. (optional)</param>
        /// <param name="typePattern">A correctly formated regular expression. Retrieve entities whose type matches the regular expression. Incompatible with &#x60;type&#x60;. (optional)</param>
        /// <param name="q">A query expression, composed of a list of statements separated by &#x60;;&#x60;, i.e., q&#x3D;statement1;statement2;statement3. See [Simple Query Language specification](#simple_query_language). (optional)</param>
        /// <param name="mq">A query expression for attribute metadata, composed of a list of statements separated by &#x60;;&#x60;, i.e., mq&#x3D;statement1;statement2;statement3. See [Simple Query Language specification](#simple_query_language). (optional)</param>
        /// <param name="georel">Spatial relationship between matching entities and a reference shape. See [Geographical Queries](#geographical_queries). (optional)</param>
        /// <param name="geometry">Geografical area to which the query is restricted. See [Geographical Queries](#geographical_queries). (optional)</param>
        /// <param name="coords">List of latitude-longitude pairs of coordinates separated by &#x27;;&#x27;. See [Geographical Queries](#geographical_queries). (optional)</param>
        /// <param name="limit">Limits the number of entities to be retrieved (optional)</param>
        /// <param name="offset">Establishes the offset from where entities are retrieved (optional)</param>
        /// <param name="attrs">Comma-separated list of attribute names whose data are to be included in the response. The attributes are retrieved in the order specified by this parameter. If this parameter is not included, the attributes are retrieved in arbitrary order. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. (optional)</param>
        /// <param name="metadata">A list of metadata names to include in the response. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. (optional)</param>
        /// <param name="orderBy">Criteria for ordering results. See \&quot;Ordering Results\&quot; section for details. (optional)</param>
        /// <param name="options">Options dictionary (optional)</param>
        /// <returns>ApiResponse of List&lt;ListEntitiesResponse&gt;</returns>
        public ApiResponse<List<ListEntitiesResponse>> ListEntitiesWithHttpInfo(string id = null,
            string type = null, string idPattern = null, string typePattern = null, string q = null, string mq = null,
            string georel = null, string geometry = null, string coords = null, double? limit = null,
            double? offset = null, string attrs = null, string metadata = null, string orderBy = null,
            string options = null)
        {
            var localVarPath = "/v2/entities";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[]
            {
            };
            String localVarHttpContentType =
                this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[]
            {
                "application/json"
            };
            String localVarHttpHeaderAccept =
                this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null)
                localVarQueryParams.AddRange(
                    this.Configuration.ApiClient.ParameterToKeyValuePairs("", "id", id)); // query parameter
            if (type != null)
                localVarQueryParams.AddRange(
                    this.Configuration.ApiClient.ParameterToKeyValuePairs("", "type", type)); // query parameter
            if (idPattern != null)
                localVarQueryParams.AddRange(
                    this.Configuration.ApiClient.ParameterToKeyValuePairs("", "idPattern",
                        idPattern)); // query parameter
            if (typePattern != null)
                localVarQueryParams.AddRange(
                    this.Configuration.ApiClient.ParameterToKeyValuePairs("", "typePattern",
                        typePattern)); // query parameter
            if (q != null)
                localVarQueryParams.AddRange(
                    this.Configuration.ApiClient.ParameterToKeyValuePairs("", "q", q)); // query parameter
            if (mq != null)
                localVarQueryParams.AddRange(
                    this.Configuration.ApiClient.ParameterToKeyValuePairs("", "mq", mq)); // query parameter
            if (georel != null)
                localVarQueryParams.AddRange(
                    this.Configuration.ApiClient.ParameterToKeyValuePairs("", "georel", georel)); // query parameter
            if (geometry != null)
                localVarQueryParams.AddRange(
                    this.Configuration.ApiClient.ParameterToKeyValuePairs("", "geometry", geometry)); // query parameter
            if (coords != null)
                localVarQueryParams.AddRange(
                    this.Configuration.ApiClient.ParameterToKeyValuePairs("", "coords", coords)); // query parameter
            if (limit != null)
                localVarQueryParams.AddRange(
                    this.Configuration.ApiClient.ParameterToKeyValuePairs("", "limit", limit)); // query parameter
            if (offset != null)
                localVarQueryParams.AddRange(
                    this.Configuration.ApiClient.ParameterToKeyValuePairs("", "offset", offset)); // query parameter
            if (attrs != null)
                localVarQueryParams.AddRange(
                    this.Configuration.ApiClient.ParameterToKeyValuePairs("", "attrs", attrs)); // query parameter
            if (metadata != null)
                localVarQueryParams.AddRange(
                    this.Configuration.ApiClient.ParameterToKeyValuePairs("", "metadata", metadata)); // query parameter
            if (orderBy != null)
                localVarQueryParams.AddRange(
                    this.Configuration.ApiClient.ParameterToKeyValuePairs("", "orderBy", orderBy)); // query parameter
            if (options != null)
                localVarQueryParams.AddRange(
                    this.Configuration.ApiClient.ParameterToKeyValuePairs("", "options", options)); // query parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams,
                localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListEntities", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<List<ListEntitiesResponse>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (List<ListEntitiesResponse>) this.Configuration.ApiClient.Deserialize(localVarResponse,
                    typeof(List<ListEntitiesResponse>)));
        }

        /// <summary>
        /// List Entities Retrieves a list of entities that match different criteria by id, type, pattern matching (either id or type) and/or those which match a query or geographical query (see [Simple Query Language](#simple_query_language) and  [Geographical Queries](#geographical_queries)). A given entity has to match all the criteria to be retrieved (i.e., the criteria is combined in a logical AND way). Note that pattern matching query parameters are incompatible (i.e. mutually exclusive) with their corresponding exact matching parameters, i.e. &#x60;idPattern&#x60; with &#x60;id&#x60; and &#x60;typePattern&#x60; with &#x60;type&#x60;. The response payload is an array containing one object per matching entity. Each entity follows the JSON entity representation format (described in \&quot;JSON Entity Representation\&quot; section). Response code: * Successful operation uses 200 OK * Errors use a non-2xx and (optionally) an error payload. See subsection on \&quot;Error Responses\&quot; for   more details.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A comma-separated list of elements. Retrieve entities whose ID matches one of the elements in the list. Incompatible with &#x60;idPattern&#x60;. (optional)</param>
        /// <param name="type">comma-separated list of elements. Retrieve entities whose type matches one of the elements in the list. Incompatible with &#x60;typePattern&#x60;. (optional)</param>
        /// <param name="idPattern">A correctly formated regular expression. Retrieve entities whose ID matches the regular expression. Incompatible with &#x60;id&#x60;. (optional)</param>
        /// <param name="typePattern">A correctly formated regular expression. Retrieve entities whose type matches the regular expression. Incompatible with &#x60;type&#x60;. (optional)</param>
        /// <param name="q">A query expression, composed of a list of statements separated by &#x60;;&#x60;, i.e., q&#x3D;statement1;statement2;statement3. See [Simple Query Language specification](#simple_query_language). (optional)</param>
        /// <param name="mq">A query expression for attribute metadata, composed of a list of statements separated by &#x60;;&#x60;, i.e., mq&#x3D;statement1;statement2;statement3. See [Simple Query Language specification](#simple_query_language). (optional)</param>
        /// <param name="georel">Spatial relationship between matching entities and a reference shape. See [Geographical Queries](#geographical_queries). (optional)</param>
        /// <param name="geometry">Geografical area to which the query is restricted. See [Geographical Queries](#geographical_queries). (optional)</param>
        /// <param name="coords">List of latitude-longitude pairs of coordinates separated by &#x27;;&#x27;. See [Geographical Queries](#geographical_queries). (optional)</param>
        /// <param name="limit">Limits the number of entities to be retrieved (optional)</param>
        /// <param name="offset">Establishes the offset from where entities are retrieved (optional)</param>
        /// <param name="attrs">Comma-separated list of attribute names whose data are to be included in the response. The attributes are retrieved in the order specified by this parameter. If this parameter is not included, the attributes are retrieved in arbitrary order. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. (optional)</param>
        /// <param name="metadata">A list of metadata names to include in the response. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. (optional)</param>
        /// <param name="orderBy">Criteria for ordering results. See \&quot;Ordering Results\&quot; section for details. (optional)</param>
        /// <param name="options">Options dictionary (optional)</param>
        /// <returns>Task of List&lt;ListEntitiesResponse&gt;</returns>
        public async System.Threading.Tasks.Task<List<ListEntitiesResponse>> ListEntitiesAsync(string id = null,
            string type = null, string idPattern = null, string typePattern = null, string q = null, string mq = null,
            string georel = null, string geometry = null, string coords = null, double? limit = null,
            double? offset = null, string attrs = null, string metadata = null, string orderBy = null,
            string options = null)
        {
            ApiResponse<List<ListEntitiesResponse>> localVarResponse = await ListEntitiesAsyncWithHttpInfo(id, type,
                idPattern, typePattern, q, mq, georel, geometry, coords, limit, offset, attrs, metadata, orderBy,
                options);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List Entities Retrieves a list of entities that match different criteria by id, type, pattern matching (either id or type) and/or those which match a query or geographical query (see [Simple Query Language](#simple_query_language) and  [Geographical Queries](#geographical_queries)). A given entity has to match all the criteria to be retrieved (i.e., the criteria is combined in a logical AND way). Note that pattern matching query parameters are incompatible (i.e. mutually exclusive) with their corresponding exact matching parameters, i.e. &#x60;idPattern&#x60; with &#x60;id&#x60; and &#x60;typePattern&#x60; with &#x60;type&#x60;. The response payload is an array containing one object per matching entity. Each entity follows the JSON entity representation format (described in \&quot;JSON Entity Representation\&quot; section). Response code: * Successful operation uses 200 OK * Errors use a non-2xx and (optionally) an error payload. See subsection on \&quot;Error Responses\&quot; for   more details.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A comma-separated list of elements. Retrieve entities whose ID matches one of the elements in the list. Incompatible with &#x60;idPattern&#x60;. (optional)</param>
        /// <param name="type">comma-separated list of elements. Retrieve entities whose type matches one of the elements in the list. Incompatible with &#x60;typePattern&#x60;. (optional)</param>
        /// <param name="idPattern">A correctly formated regular expression. Retrieve entities whose ID matches the regular expression. Incompatible with &#x60;id&#x60;. (optional)</param>
        /// <param name="typePattern">A correctly formated regular expression. Retrieve entities whose type matches the regular expression. Incompatible with &#x60;type&#x60;. (optional)</param>
        /// <param name="q">A query expression, composed of a list of statements separated by &#x60;;&#x60;, i.e., q&#x3D;statement1;statement2;statement3. See [Simple Query Language specification](#simple_query_language). (optional)</param>
        /// <param name="mq">A query expression for attribute metadata, composed of a list of statements separated by &#x60;;&#x60;, i.e., mq&#x3D;statement1;statement2;statement3. See [Simple Query Language specification](#simple_query_language). (optional)</param>
        /// <param name="georel">Spatial relationship between matching entities and a reference shape. See [Geographical Queries](#geographical_queries). (optional)</param>
        /// <param name="geometry">Geografical area to which the query is restricted. See [Geographical Queries](#geographical_queries). (optional)</param>
        /// <param name="coords">List of latitude-longitude pairs of coordinates separated by &#x27;;&#x27;. See [Geographical Queries](#geographical_queries). (optional)</param>
        /// <param name="limit">Limits the number of entities to be retrieved (optional)</param>
        /// <param name="offset">Establishes the offset from where entities are retrieved (optional)</param>
        /// <param name="attrs">Comma-separated list of attribute names whose data are to be included in the response. The attributes are retrieved in the order specified by this parameter. If this parameter is not included, the attributes are retrieved in arbitrary order. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. (optional)</param>
        /// <param name="metadata">A list of metadata names to include in the response. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. (optional)</param>
        /// <param name="orderBy">Criteria for ordering results. See \&quot;Ordering Results\&quot; section for details. (optional)</param>
        /// <param name="options">Options dictionary (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;ListEntitiesResponse&gt;)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<List<ListEntitiesResponse>>>
            ListEntitiesAsyncWithHttpInfo(string id = null, string type = null, string idPattern = null,
                string typePattern = null, string q = null, string mq = null, string georel = null,
                string geometry = null, string coords = null, double? limit = null, double? offset = null,
                string attrs = null, string metadata = null, string orderBy = null, string options = null)
        {
            var localVarPath = "/v2/entities";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[]
            {
            };
            String localVarHttpContentType =
                this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[]
            {
                "application/json"
            };
            String localVarHttpHeaderAccept =
                this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null)
                localVarQueryParams.AddRange(
                    this.Configuration.ApiClient.ParameterToKeyValuePairs("", "id", id)); // query parameter
            if (type != null)
                localVarQueryParams.AddRange(
                    this.Configuration.ApiClient.ParameterToKeyValuePairs("", "type", type)); // query parameter
            if (idPattern != null)
                localVarQueryParams.AddRange(
                    this.Configuration.ApiClient.ParameterToKeyValuePairs("", "idPattern",
                        idPattern)); // query parameter
            if (typePattern != null)
                localVarQueryParams.AddRange(
                    this.Configuration.ApiClient.ParameterToKeyValuePairs("", "typePattern",
                        typePattern)); // query parameter
            if (q != null)
                localVarQueryParams.AddRange(
                    this.Configuration.ApiClient.ParameterToKeyValuePairs("", "q", q)); // query parameter
            if (mq != null)
                localVarQueryParams.AddRange(
                    this.Configuration.ApiClient.ParameterToKeyValuePairs("", "mq", mq)); // query parameter
            if (georel != null)
                localVarQueryParams.AddRange(
                    this.Configuration.ApiClient.ParameterToKeyValuePairs("", "georel", georel)); // query parameter
            if (geometry != null)
                localVarQueryParams.AddRange(
                    this.Configuration.ApiClient.ParameterToKeyValuePairs("", "geometry", geometry)); // query parameter
            if (coords != null)
                localVarQueryParams.AddRange(
                    this.Configuration.ApiClient.ParameterToKeyValuePairs("", "coords", coords)); // query parameter
            if (limit != null)
                localVarQueryParams.AddRange(
                    this.Configuration.ApiClient.ParameterToKeyValuePairs("", "limit", limit)); // query parameter
            if (offset != null)
                localVarQueryParams.AddRange(
                    this.Configuration.ApiClient.ParameterToKeyValuePairs("", "offset", offset)); // query parameter
            if (attrs != null)
                localVarQueryParams.AddRange(
                    this.Configuration.ApiClient.ParameterToKeyValuePairs("", "attrs", attrs)); // query parameter
            if (metadata != null)
                localVarQueryParams.AddRange(
                    this.Configuration.ApiClient.ParameterToKeyValuePairs("", "metadata", metadata)); // query parameter
            if (orderBy != null)
                localVarQueryParams.AddRange(
                    this.Configuration.ApiClient.ParameterToKeyValuePairs("", "orderBy", orderBy)); // query parameter
            if (options != null)
                localVarQueryParams.AddRange(
                    this.Configuration.ApiClient.ParameterToKeyValuePairs("", "options", options)); // query parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(
                localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams,
                localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListEntities", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<List<ListEntitiesResponse>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (List<ListEntitiesResponse>) this.Configuration.ApiClient.Deserialize(localVarResponse,
                    typeof(List<ListEntitiesResponse>)));
        }

        /// <summary>
        /// Remove Entity Delete the entity. Response: * Successful operation uses 204 No Content * Errors use a non-2xx and (optionally) an error payload. See subsection on \&quot;Error Responses\&quot; for   more details.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityId">Id of the entity to be deleted</param>
        /// <param name="type">Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)</param>
        /// <returns></returns>
        public void RemoveEntity(string entityId, string type = null)
        {
            RemoveEntityWithHttpInfo(entityId, type);
        }

        /// <summary>
        /// Remove Entity Delete the entity. Response: * Successful operation uses 204 No Content * Errors use a non-2xx and (optionally) an error payload. See subsection on \&quot;Error Responses\&quot; for   more details.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityId">Id of the entity to be deleted</param>
        /// <param name="type">Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> RemoveEntityWithHttpInfo(string entityId, string type = null)
        {
            // verify the required parameter 'entityId' is set
            if (entityId == null)
                throw new ApiException(400,
                    "Missing required parameter 'entityId' when calling EntitiesApi->RemoveEntity");

            var localVarPath = "/v2/entities/{entityId}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[]
            {
            };
            String localVarHttpContentType =
                this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[]
            {
            };
            String localVarHttpHeaderAccept =
                this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (entityId != null)
                localVarPathParams.Add("entityId",
                    this.Configuration.ApiClient.ParameterToString(entityId)); // path parameter
            if (type != null)
                localVarQueryParams.AddRange(
                    this.Configuration.ApiClient.ParameterToKeyValuePairs("", "type", type)); // query parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams,
                localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemoveEntity", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Remove Entity Delete the entity. Response: * Successful operation uses 204 No Content * Errors use a non-2xx and (optionally) an error payload. See subsection on \&quot;Error Responses\&quot; for   more details.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityId">Id of the entity to be deleted</param>
        /// <param name="type">Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RemoveEntityAsync(string entityId, string type = null)
        {
            await RemoveEntityAsyncWithHttpInfo(entityId, type);
        }

        /// <summary>
        /// Remove Entity Delete the entity. Response: * Successful operation uses 204 No Content * Errors use a non-2xx and (optionally) an error payload. See subsection on \&quot;Error Responses\&quot; for   more details.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityId">Id of the entity to be deleted</param>
        /// <param name="type">Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> RemoveEntityAsyncWithHttpInfo(string entityId,
            string type = null)
        {
            // verify the required parameter 'entityId' is set
            if (entityId == null)
                throw new ApiException(400,
                    "Missing required parameter 'entityId' when calling EntitiesApi->RemoveEntity");

            var localVarPath = "/v2/entities/{entityId}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[]
            {
            };
            String localVarHttpContentType =
                this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[]
            {
            };
            String localVarHttpHeaderAccept =
                this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (entityId != null)
                localVarPathParams.Add("entityId",
                    this.Configuration.ApiClient.ParameterToString(entityId)); // path parameter
            if (type != null)
                localVarQueryParams.AddRange(
                    this.Configuration.ApiClient.ParameterToKeyValuePairs("", "type", type)); // query parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(
                localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams,
                localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemoveEntity", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Replace all entity attributes The request payload is an object representing the new entity attributes. The object follows the JSON entity representation format (described in a \&quot;JSON Entity Representation\&quot; above), except that &#x60;id&#x60; and &#x60;type&#x60; are not allowed. The attributes previously existing in the entity are removed and replaced by the ones in the request. Response: * Successful operation uses 204 No Content * Errors use a non-2xx and (optionally) an error payload. See subsection on \&quot;Error Responses\&quot; for   more details.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"></param>
        /// <param name="contentType"></param>
        /// <param name="entityId">Id of the entity in question.</param>
        /// <param name="type">Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)</param>
        /// <param name="options">Operations options (optional)</param>
        /// <returns></returns>
        public void ReplaceAllEntityAttributes(ReplaceAllEntityAttributesRequest body, string contentType,
            string entityId, string type = null, string options = null)
        {
            ReplaceAllEntityAttributesWithHttpInfo(body, contentType, entityId, type, options);
        }

        /// <summary>
        /// Replace all entity attributes The request payload is an object representing the new entity attributes. The object follows the JSON entity representation format (described in a \&quot;JSON Entity Representation\&quot; above), except that &#x60;id&#x60; and &#x60;type&#x60; are not allowed. The attributes previously existing in the entity are removed and replaced by the ones in the request. Response: * Successful operation uses 204 No Content * Errors use a non-2xx and (optionally) an error payload. See subsection on \&quot;Error Responses\&quot; for   more details.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"></param>
        /// <param name="contentType"></param>
        /// <param name="entityId">Id of the entity in question.</param>
        /// <param name="type">Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)</param>
        /// <param name="options">Operations options (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> ReplaceAllEntityAttributesWithHttpInfo(ReplaceAllEntityAttributesRequest body,
            string contentType, string entityId, string type = null, string options = null)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400,
                    "Missing required parameter 'body' when calling EntitiesApi->ReplaceAllEntityAttributes");
            // verify the required parameter 'contentType' is set
            if (contentType == null)
                throw new ApiException(400,
                    "Missing required parameter 'contentType' when calling EntitiesApi->ReplaceAllEntityAttributes");
            // verify the required parameter 'entityId' is set
            if (entityId == null)
                throw new ApiException(400,
                    "Missing required parameter 'entityId' when calling EntitiesApi->ReplaceAllEntityAttributes");

            var localVarPath = "/v2/entities/{entityId}/attrs";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[]
            {
                "application/json"
            };
            String localVarHttpContentType =
                this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[]
            {
            };
            String localVarHttpHeaderAccept =
                this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (entityId != null)
                localVarPathParams.Add("entityId",
                    this.Configuration.ApiClient.ParameterToString(entityId)); // path parameter
            if (type != null)
                localVarQueryParams.AddRange(
                    this.Configuration.ApiClient.ParameterToKeyValuePairs("", "type", type)); // query parameter
            if (options != null)
                localVarQueryParams.AddRange(
                    this.Configuration.ApiClient.ParameterToKeyValuePairs("", "options", options)); // query parameter
            if (contentType != null)
                localVarHeaderParams.Add("Content-Type",
                    this.Configuration.ApiClient.ParameterToString(contentType)); // header parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams,
                localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceAllEntityAttributes", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Replace all entity attributes The request payload is an object representing the new entity attributes. The object follows the JSON entity representation format (described in a \&quot;JSON Entity Representation\&quot; above), except that &#x60;id&#x60; and &#x60;type&#x60; are not allowed. The attributes previously existing in the entity are removed and replaced by the ones in the request. Response: * Successful operation uses 204 No Content * Errors use a non-2xx and (optionally) an error payload. See subsection on \&quot;Error Responses\&quot; for   more details.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"></param>
        /// <param name="contentType"></param>
        /// <param name="entityId">Id of the entity in question.</param>
        /// <param name="type">Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)</param>
        /// <param name="options">Operations options (optional)</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task ReplaceAllEntityAttributesAsync(ReplaceAllEntityAttributesRequest body,
            string contentType, string entityId, string type = null, string options = null)
        {
            await ReplaceAllEntityAttributesAsyncWithHttpInfo(body, contentType, entityId, type, options);
        }

        /// <summary>
        /// Replace all entity attributes The request payload is an object representing the new entity attributes. The object follows the JSON entity representation format (described in a \&quot;JSON Entity Representation\&quot; above), except that &#x60;id&#x60; and &#x60;type&#x60; are not allowed. The attributes previously existing in the entity are removed and replaced by the ones in the request. Response: * Successful operation uses 204 No Content * Errors use a non-2xx and (optionally) an error payload. See subsection on \&quot;Error Responses\&quot; for   more details.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"></param>
        /// <param name="contentType"></param>
        /// <param name="entityId">Id of the entity in question.</param>
        /// <param name="type">Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)</param>
        /// <param name="options">Operations options (optional)</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> ReplaceAllEntityAttributesAsyncWithHttpInfo(
            ReplaceAllEntityAttributesRequest body, string contentType, string entityId, string type = null,
            string options = null)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400,
                    "Missing required parameter 'body' when calling EntitiesApi->ReplaceAllEntityAttributes");
            // verify the required parameter 'contentType' is set
            if (contentType == null)
                throw new ApiException(400,
                    "Missing required parameter 'contentType' when calling EntitiesApi->ReplaceAllEntityAttributes");
            // verify the required parameter 'entityId' is set
            if (entityId == null)
                throw new ApiException(400,
                    "Missing required parameter 'entityId' when calling EntitiesApi->ReplaceAllEntityAttributes");

            var localVarPath = "/v2/entities/{entityId}/attrs";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[]
            {
                "application/json"
            };
            String localVarHttpContentType =
                this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[]
            {
            };
            String localVarHttpHeaderAccept =
                this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (entityId != null)
                localVarPathParams.Add("entityId",
                    this.Configuration.ApiClient.ParameterToString(entityId)); // path parameter
            if (type != null)
                localVarQueryParams.AddRange(
                    this.Configuration.ApiClient.ParameterToKeyValuePairs("", "type", type)); // query parameter
            if (options != null)
                localVarQueryParams.AddRange(
                    this.Configuration.ApiClient.ParameterToKeyValuePairs("", "options", options)); // query parameter
            if (contentType != null)
                localVarHeaderParams.Add("Content-Type",
                    this.Configuration.ApiClient.ParameterToString(contentType)); // header parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(
                localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams,
                localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceAllEntityAttributes", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Retrieve Entity The response is an object representing the entity identified by the ID. The object follows the JSON entity representation format (described in \&quot;JSON Entity Representation\&quot; section). This operation must return one entity element only, but there may be more than one entity with the same ID (e.g. entities with same ID but different types). In such case, an error message is returned, with the HTTP status code set to 409 Conflict. Response: * Successful operation uses 200 OK * Errors use a non-2xx and (optionally) an error payload. See subsection on \&quot;Error Responses\&quot; for more details.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityId">Id of the entity to be retrieved</param>
        /// <param name="type">Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)</param>
        /// <param name="attrs">Comma-separated list of attribute names whose data must be included in the response. The attributes are retrieved in the order specified by this parameter. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. If this parameter is not included, the attributes are retrieved in arbitrary order, and all the attributes of the entity are included in the response. (optional)</param>
        /// <param name="metadata">A list of metadata names to include in the response. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. (optional)</param>
        /// <param name="options">Options dictionary (optional)</param>
        /// <returns>RetrieveEntityResponse</returns>
        public RetrieveBedEntityResponse RetrieveEntity(string entityId, string type = null, string attrs = null,
            string metadata = null, string options = null)
        {
            ApiResponse<RetrieveBedEntityResponse> localVarResponse =
                RetrieveEntityWithHttpInfo(entityId, type, attrs, metadata, options);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Retrieve Entity The response is an object representing the entity identified by the ID. The object follows the JSON entity representation format (described in \&quot;JSON Entity Representation\&quot; section). This operation must return one entity element only, but there may be more than one entity with the same ID (e.g. entities with same ID but different types). In such case, an error message is returned, with the HTTP status code set to 409 Conflict. Response: * Successful operation uses 200 OK * Errors use a non-2xx and (optionally) an error payload. See subsection on \&quot;Error Responses\&quot; for more details.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityId">Id of the entity to be retrieved</param>
        /// <param name="type">Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)</param>
        /// <param name="attrs">Comma-separated list of attribute names whose data must be included in the response. The attributes are retrieved in the order specified by this parameter. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. If this parameter is not included, the attributes are retrieved in arbitrary order, and all the attributes of the entity are included in the response. (optional)</param>
        /// <param name="metadata">A list of metadata names to include in the response. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. (optional)</param>
        /// <param name="options">Options dictionary (optional)</param>
        /// <returns>ApiResponse of RetrieveEntityResponse</returns>
        public ApiResponse<RetrieveBedEntityResponse> RetrieveEntityWithHttpInfo(string entityId, string type = null,
            string attrs = null, string metadata = null, string options = null)
        {
            // verify the required parameter 'entityId' is set
            if (entityId == null)
                throw new ApiException(400,
                    "Missing required parameter 'entityId' when calling EntitiesApi->RetrieveEntity");

            var localVarPath = "/v2/entities/{entityId}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[]
            {
            };
            String localVarHttpContentType =
                this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[]
            {
                "application/json"
            };
            String localVarHttpHeaderAccept =
                this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (entityId != null)
                localVarPathParams.Add("entityId",
                    this.Configuration.ApiClient.ParameterToString(entityId)); // path parameter
            if (type != null)
                localVarQueryParams.AddRange(
                    this.Configuration.ApiClient.ParameterToKeyValuePairs("", "type", type)); // query parameter
            if (attrs != null)
                localVarQueryParams.AddRange(
                    this.Configuration.ApiClient.ParameterToKeyValuePairs("", "attrs", attrs)); // query parameter
            if (metadata != null)
                localVarQueryParams.AddRange(
                    this.Configuration.ApiClient.ParameterToKeyValuePairs("", "metadata", metadata)); // query parameter
            if (options != null)
                localVarQueryParams.AddRange(
                    this.Configuration.ApiClient.ParameterToKeyValuePairs("", "options", options)); // query parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams,
                localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RetrieveEntity", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<RetrieveBedEntityResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (RetrieveBedEntityResponse) this.Configuration.ApiClient.Deserialize(localVarResponse,
                    typeof(RetrieveBedEntityResponse)));
        }

        /// <summary>
        /// Retrieve Entity The response is an object representing the entity identified by the ID. The object follows the JSON entity representation format (described in \&quot;JSON Entity Representation\&quot; section). This operation must return one entity element only, but there may be more than one entity with the same ID (e.g. entities with same ID but different types). In such case, an error message is returned, with the HTTP status code set to 409 Conflict. Response: * Successful operation uses 200 OK * Errors use a non-2xx and (optionally) an error payload. See subsection on \&quot;Error Responses\&quot; for more details.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityId">Id of the entity to be retrieved</param>
        /// <param name="type">Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)</param>
        /// <param name="attrs">Comma-separated list of attribute names whose data must be included in the response. The attributes are retrieved in the order specified by this parameter. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. If this parameter is not included, the attributes are retrieved in arbitrary order, and all the attributes of the entity are included in the response. (optional)</param>
        /// <param name="metadata">A list of metadata names to include in the response. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. (optional)</param>
        /// <param name="options">Options dictionary (optional)</param>
        /// <returns>Task of RetrieveEntityResponse</returns>
        public async System.Threading.Tasks.Task<RetrieveBedEntityResponse> RetrieveBedEntityAsync(string entityId,
            string type = null, string attrs = null, string metadata = null, string options = null)
        {
            ApiResponse<RetrieveBedEntityResponse> localVarResponse =
                await RetrieveEntityAsyncWithHttpInfo(entityId, type, attrs, metadata, options);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Retrieve Entity The response is an object representing the entity identified by the ID. The object follows the JSON entity representation format (described in \&quot;JSON Entity Representation\&quot; section). This operation must return one entity element only, but there may be more than one entity with the same ID (e.g. entities with same ID but different types). In such case, an error message is returned, with the HTTP status code set to 409 Conflict. Response: * Successful operation uses 200 OK * Errors use a non-2xx and (optionally) an error payload. See subsection on \&quot;Error Responses\&quot; for more details.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityId">Id of the entity to be retrieved</param>
        /// <param name="type">Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)</param>
        /// <param name="attrs">Comma-separated list of attribute names whose data must be included in the response. The attributes are retrieved in the order specified by this parameter. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. If this parameter is not included, the attributes are retrieved in arbitrary order, and all the attributes of the entity are included in the response. (optional)</param>
        /// <param name="metadata">A list of metadata names to include in the response. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. (optional)</param>
        /// <param name="options">Options dictionary (optional)</param>
        /// <returns>Task of ApiResponse (RetrieveEntityResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<RetrieveBedEntityResponse>> RetrieveEntityAsyncWithHttpInfo(
            string entityId, string type = null, string attrs = null, string metadata = null, string options = null)
        {
            // verify the required parameter 'entityId' is set
            if (entityId == null)
                throw new ApiException(400,
                    "Missing required parameter 'entityId' when calling EntitiesApi->RetrieveEntity");

            var localVarPath = "/v2/entities/{entityId}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[]
            {
            };
            String localVarHttpContentType =
                this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[]
            {
                "application/json"
            };
            String localVarHttpHeaderAccept =
                this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (entityId != null)
                localVarPathParams.Add("entityId",
                    this.Configuration.ApiClient.ParameterToString(entityId)); // path parameter
            if (type != null)
                localVarQueryParams.AddRange(
                    this.Configuration.ApiClient.ParameterToKeyValuePairs("", "type", type)); // query parameter
            if (attrs != null)
                localVarQueryParams.AddRange(
                    this.Configuration.ApiClient.ParameterToKeyValuePairs("", "attrs", attrs)); // query parameter
            if (metadata != null)
                localVarQueryParams.AddRange(
                    this.Configuration.ApiClient.ParameterToKeyValuePairs("", "metadata", metadata)); // query parameter
            if (options != null)
                localVarQueryParams.AddRange(
                    this.Configuration.ApiClient.ParameterToKeyValuePairs("", "options", options)); // query parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(
                localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams,
                localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RetrieveEntity", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<RetrieveBedEntityResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (RetrieveBedEntityResponse) this.Configuration.ApiClient.Deserialize(localVarResponse,
                    typeof(RetrieveBedEntityResponse)));
        }

        /// <summary>
        /// Retrieve Entity Attributes This request is similar to retreiving the whole entity, however this one omits the &#x60;id&#x60; and &#x60;type&#x60; fields. Just like the general request of getting an entire entity, this operation must return only one entity element. If more than one entity with the same ID is found (e.g. entities with same ID but different type), an error message is returned, with the HTTP status code set to 409 Conflict. Response: * Successful operation uses 200 OK * Errors use a non-2xx and (optionally) an error payload. See subsection on \&quot;Error Responses\&quot; for   more details.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityId">Id of the entity to be retrieved</param>
        /// <param name="type">Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)</param>
        /// <param name="attrs">Comma-separated list of attribute names whose data are to be included in the response. The attributes are retrieved in the order specified by this parameter. If this parameter is not included, the attributes are retrieved in arbitrary order, and all the attributes of the entity are included in the response. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. (optional)</param>
        /// <param name="metadata">A list of metadata names to include in the response. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. (optional)</param>
        /// <param name="options">Options dictionary (optional)</param>
        /// <returns>RetrieveEntityAttributesResponse</returns>
        public RetrieveEntityAttributesResponse RetrieveEntityAttributes(string entityId, string type = null,
            string attrs = null, string metadata = null, string options = null)
        {
            ApiResponse<RetrieveEntityAttributesResponse> localVarResponse =
                RetrieveEntityAttributesWithHttpInfo(entityId, type, attrs, metadata, options);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Retrieve Entity Attributes This request is similar to retreiving the whole entity, however this one omits the &#x60;id&#x60; and &#x60;type&#x60; fields. Just like the general request of getting an entire entity, this operation must return only one entity element. If more than one entity with the same ID is found (e.g. entities with same ID but different type), an error message is returned, with the HTTP status code set to 409 Conflict. Response: * Successful operation uses 200 OK * Errors use a non-2xx and (optionally) an error payload. See subsection on \&quot;Error Responses\&quot; for   more details.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityId">Id of the entity to be retrieved</param>
        /// <param name="type">Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)</param>
        /// <param name="attrs">Comma-separated list of attribute names whose data are to be included in the response. The attributes are retrieved in the order specified by this parameter. If this parameter is not included, the attributes are retrieved in arbitrary order, and all the attributes of the entity are included in the response. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. (optional)</param>
        /// <param name="metadata">A list of metadata names to include in the response. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. (optional)</param>
        /// <param name="options">Options dictionary (optional)</param>
        /// <returns>ApiResponse of RetrieveEntityAttributesResponse</returns>
        public ApiResponse<RetrieveEntityAttributesResponse> RetrieveEntityAttributesWithHttpInfo(string entityId,
            string type = null, string attrs = null, string metadata = null, string options = null)
        {
            // verify the required parameter 'entityId' is set
            if (entityId == null)
                throw new ApiException(400,
                    "Missing required parameter 'entityId' when calling EntitiesApi->RetrieveEntityAttributes");

            var localVarPath = "/v2/entities/{entityId}/attrs";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[]
            {
            };
            String localVarHttpContentType =
                this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[]
            {
                "application/json"
            };
            String localVarHttpHeaderAccept =
                this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (entityId != null)
                localVarPathParams.Add("entityId",
                    this.Configuration.ApiClient.ParameterToString(entityId)); // path parameter
            if (type != null)
                localVarQueryParams.AddRange(
                    this.Configuration.ApiClient.ParameterToKeyValuePairs("", "type", type)); // query parameter
            if (attrs != null)
                localVarQueryParams.AddRange(
                    this.Configuration.ApiClient.ParameterToKeyValuePairs("", "attrs", attrs)); // query parameter
            if (metadata != null)
                localVarQueryParams.AddRange(
                    this.Configuration.ApiClient.ParameterToKeyValuePairs("", "metadata", metadata)); // query parameter
            if (options != null)
                localVarQueryParams.AddRange(
                    this.Configuration.ApiClient.ParameterToKeyValuePairs("", "options", options)); // query parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams,
                localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RetrieveEntityAttributes", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<RetrieveEntityAttributesResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (RetrieveEntityAttributesResponse) this.Configuration.ApiClient.Deserialize(localVarResponse,
                    typeof(RetrieveEntityAttributesResponse)));
        }

        /// <summary>
        /// Retrieve Entity Attributes This request is similar to retreiving the whole entity, however this one omits the &#x60;id&#x60; and &#x60;type&#x60; fields. Just like the general request of getting an entire entity, this operation must return only one entity element. If more than one entity with the same ID is found (e.g. entities with same ID but different type), an error message is returned, with the HTTP status code set to 409 Conflict. Response: * Successful operation uses 200 OK * Errors use a non-2xx and (optionally) an error payload. See subsection on \&quot;Error Responses\&quot; for   more details.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityId">Id of the entity to be retrieved</param>
        /// <param name="type">Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)</param>
        /// <param name="attrs">Comma-separated list of attribute names whose data are to be included in the response. The attributes are retrieved in the order specified by this parameter. If this parameter is not included, the attributes are retrieved in arbitrary order, and all the attributes of the entity are included in the response. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. (optional)</param>
        /// <param name="metadata">A list of metadata names to include in the response. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. (optional)</param>
        /// <param name="options">Options dictionary (optional)</param>
        /// <returns>Task of RetrieveEntityAttributesResponse</returns>
        public async System.Threading.Tasks.Task<RetrieveEntityAttributesResponse> RetrieveEntityAttributesAsync(
            string entityId, string type = null, string attrs = null, string metadata = null, string options = null)
        {
            ApiResponse<RetrieveEntityAttributesResponse> localVarResponse =
                await RetrieveEntityAttributesAsyncWithHttpInfo(entityId, type, attrs, metadata, options);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Retrieve Entity Attributes This request is similar to retreiving the whole entity, however this one omits the &#x60;id&#x60; and &#x60;type&#x60; fields. Just like the general request of getting an entire entity, this operation must return only one entity element. If more than one entity with the same ID is found (e.g. entities with same ID but different type), an error message is returned, with the HTTP status code set to 409 Conflict. Response: * Successful operation uses 200 OK * Errors use a non-2xx and (optionally) an error payload. See subsection on \&quot;Error Responses\&quot; for   more details.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="entityId">Id of the entity to be retrieved</param>
        /// <param name="type">Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)</param>
        /// <param name="attrs">Comma-separated list of attribute names whose data are to be included in the response. The attributes are retrieved in the order specified by this parameter. If this parameter is not included, the attributes are retrieved in arbitrary order, and all the attributes of the entity are included in the response. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. (optional)</param>
        /// <param name="metadata">A list of metadata names to include in the response. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. (optional)</param>
        /// <param name="options">Options dictionary (optional)</param>
        /// <returns>Task of ApiResponse (RetrieveEntityAttributesResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<RetrieveEntityAttributesResponse>>
            RetrieveEntityAttributesAsyncWithHttpInfo(string entityId, string type = null, string attrs = null,
                string metadata = null, string options = null)
        {
            // verify the required parameter 'entityId' is set
            if (entityId == null)
                throw new ApiException(400,
                    "Missing required parameter 'entityId' when calling EntitiesApi->RetrieveEntityAttributes");

            var localVarPath = "/v2/entities/{entityId}/attrs";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[]
            {
            };
            String localVarHttpContentType =
                this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[]
            {
                "application/json"
            };
            String localVarHttpHeaderAccept =
                this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (entityId != null)
                localVarPathParams.Add("entityId",
                    this.Configuration.ApiClient.ParameterToString(entityId)); // path parameter
            if (type != null)
                localVarQueryParams.AddRange(
                    this.Configuration.ApiClient.ParameterToKeyValuePairs("", "type", type)); // query parameter
            if (attrs != null)
                localVarQueryParams.AddRange(
                    this.Configuration.ApiClient.ParameterToKeyValuePairs("", "attrs", attrs)); // query parameter
            if (metadata != null)
                localVarQueryParams.AddRange(
                    this.Configuration.ApiClient.ParameterToKeyValuePairs("", "metadata", metadata)); // query parameter
            if (options != null)
                localVarQueryParams.AddRange(
                    this.Configuration.ApiClient.ParameterToKeyValuePairs("", "options", options)); // query parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(
                localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams,
                localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RetrieveEntityAttributes", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<RetrieveEntityAttributesResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (RetrieveEntityAttributesResponse) this.Configuration.ApiClient.Deserialize(localVarResponse,
                    typeof(RetrieveEntityAttributesResponse)));
        }

        /// <summary>
        /// Update Existing Entity Attributes The request payload is an object representing the attributes to update. The object follows the JSON entity representation format (described in \&quot;JSON Entity Representation\&quot; section), except that &#x60;id&#x60; and &#x60;type&#x60; are not allowed. The entity attributes are updated with the ones in the payload. In addition to that, if one or more attributes in the payload doesn&#x27;t exist in the entity, an error is returned. Response: * Successful operation uses 204 No Content * Errors use a non-2xx and (optionally) an error payload. See subsection on \&quot;Error Responses\&quot; for   more details.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"></param>
        /// <param name="contentType"></param>
        /// <param name="entityId">Id of the entity to be updated</param>
        /// <param name="type">Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)</param>
        /// <param name="options">Operations options (optional)</param>
        /// <returns></returns>
        public void UpdateExistingEntityAttributes(UpdateExistingEntityAttributesRequest body, string contentType,
            string entityId, string type = null, string options = null)
        {
            UpdateExistingEntityAttributesWithHttpInfo(body, contentType, entityId, type, options);
        }

        /// <summary>
        /// Update Existing Entity Attributes The request payload is an object representing the attributes to update. The object follows the JSON entity representation format (described in \&quot;JSON Entity Representation\&quot; section), except that &#x60;id&#x60; and &#x60;type&#x60; are not allowed. The entity attributes are updated with the ones in the payload. In addition to that, if one or more attributes in the payload doesn&#x27;t exist in the entity, an error is returned. Response: * Successful operation uses 204 No Content * Errors use a non-2xx and (optionally) an error payload. See subsection on \&quot;Error Responses\&quot; for   more details.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"></param>
        /// <param name="contentType"></param>
        /// <param name="entityId">Id of the entity to be updated</param>
        /// <param name="type">Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)</param>
        /// <param name="options">Operations options (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateExistingEntityAttributesWithHttpInfo(
            UpdateExistingEntityAttributesRequest body, string contentType, string entityId, string type = null,
            string options = null)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400,
                    "Missing required parameter 'body' when calling EntitiesApi->UpdateExistingEntityAttributes");
            // verify the required parameter 'contentType' is set
            if (contentType == null)
                throw new ApiException(400,
                    "Missing required parameter 'contentType' when calling EntitiesApi->UpdateExistingEntityAttributes");
            // verify the required parameter 'entityId' is set
            if (entityId == null)
                throw new ApiException(400,
                    "Missing required parameter 'entityId' when calling EntitiesApi->UpdateExistingEntityAttributes");

            var localVarPath = "/v2/entities/{entityId}/attrs";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[]
            {
                "application/json"
            };
            String localVarHttpContentType =
                this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[]
            {
            };
            String localVarHttpHeaderAccept =
                this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (entityId != null)
                localVarPathParams.Add("entityId",
                    this.Configuration.ApiClient.ParameterToString(entityId)); // path parameter
            if (type != null)
                localVarQueryParams.AddRange(
                    this.Configuration.ApiClient.ParameterToKeyValuePairs("", "type", type)); // query parameter
            if (options != null)
                localVarQueryParams.AddRange(
                    this.Configuration.ApiClient.ParameterToKeyValuePairs("", "options", options)); // query parameter
            if (contentType != null)
                localVarHeaderParams.Add("Content-Type",
                    this.Configuration.ApiClient.ParameterToString(contentType)); // header parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams,
                localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateExistingEntityAttributes", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Update Existing Entity Attributes The request payload is an object representing the attributes to update. The object follows the JSON entity representation format (described in \&quot;JSON Entity Representation\&quot; section), except that &#x60;id&#x60; and &#x60;type&#x60; are not allowed. The entity attributes are updated with the ones in the payload. In addition to that, if one or more attributes in the payload doesn&#x27;t exist in the entity, an error is returned. Response: * Successful operation uses 204 No Content * Errors use a non-2xx and (optionally) an error payload. See subsection on \&quot;Error Responses\&quot; for   more details.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"></param>
        /// <param name="contentType"></param>
        /// <param name="entityId">Id of the entity to be updated</param>
        /// <param name="type">Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)</param>
        /// <param name="options">Operations options (optional)</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task UpdateExistingEntityAttributesAsync(
            UpdateExistingEntityAttributesRequest body, string contentType, string entityId, string type = null,
            string options = null)
        {
            await UpdateExistingEntityAttributesAsyncWithHttpInfo(body, contentType, entityId, type, options);
        }

        /// <summary>
        /// Update Existing Entity Attributes The request payload is an object representing the attributes to update. The object follows the JSON entity representation format (described in \&quot;JSON Entity Representation\&quot; section), except that &#x60;id&#x60; and &#x60;type&#x60; are not allowed. The entity attributes are updated with the ones in the payload. In addition to that, if one or more attributes in the payload doesn&#x27;t exist in the entity, an error is returned. Response: * Successful operation uses 204 No Content * Errors use a non-2xx and (optionally) an error payload. See subsection on \&quot;Error Responses\&quot; for   more details.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"></param>
        /// <param name="contentType"></param>
        /// <param name="entityId">Id of the entity to be updated</param>
        /// <param name="type">Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)</param>
        /// <param name="options">Operations options (optional)</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> UpdateExistingEntityAttributesAsyncWithHttpInfo(
            UpdateExistingEntityAttributesRequest body, string contentType, string entityId, string type = null,
            string options = null)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400,
                    "Missing required parameter 'body' when calling EntitiesApi->UpdateExistingEntityAttributes");
            // verify the required parameter 'contentType' is set
            if (contentType == null)
                throw new ApiException(400,
                    "Missing required parameter 'contentType' when calling EntitiesApi->UpdateExistingEntityAttributes");
            // verify the required parameter 'entityId' is set
            if (entityId == null)
                throw new ApiException(400,
                    "Missing required parameter 'entityId' when calling EntitiesApi->UpdateExistingEntityAttributes");

            var localVarPath = "/v2/entities/{entityId}/attrs";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[]
            {
                "application/json"
            };
            String localVarHttpContentType =
                this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[]
            {
            };
            String localVarHttpHeaderAccept =
                this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (entityId != null)
                localVarPathParams.Add("entityId",
                    this.Configuration.ApiClient.ParameterToString(entityId)); // path parameter
            if (type != null)
                localVarQueryParams.AddRange(
                    this.Configuration.ApiClient.ParameterToKeyValuePairs("", "type", type)); // query parameter
            if (options != null)
                localVarQueryParams.AddRange(
                    this.Configuration.ApiClient.ParameterToKeyValuePairs("", "options", options)); // query parameter
            if (contentType != null)
                localVarHeaderParams.Add("Content-Type",
                    this.Configuration.ApiClient.ParameterToString(contentType)); // header parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(
                localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams,
                localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateExistingEntityAttributes", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Update or Append Entity Attributes The request payload is an object representing the attributes to append or update. The object follows the JSON entity representation format (described in \&quot;JSON Entity Representation\&quot; section), except that &#x60;id&#x60; and &#x60;type&#x60; are not allowed. The entity attributes are updated with the ones in the payload, depending on whether the &#x60;append&#x60; operation option is used or not. * If &#x60;append&#x60; is not used: the entity attributes are updated (if they previously exist) or appended   (if they don&#x27;t previously exist) with the ones in the payload. * If &#x60;append&#x60; is used (i.e. strict append semantics): all the attributes in the payload not   previously existing in the entity are appended. In addition to that, in case some of the   attributes in the payload already exist in the entity, an error is returned. Response: * Successful operation uses 204 No Content * Errors use a non-2xx and (optionally) an error payload. See subsection on \&quot;Error Responses\&quot; for   more details.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"></param>
        /// <param name="contentType"></param>
        /// <param name="entityId">Entity id to be updated</param>
        /// <param name="type">Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)</param>
        /// <param name="options">Operations options (optional)</param>
        /// <returns></returns>
        public void UpdateOrAppendEntityAttributes(UpdateOrAppendEntityAttributesRequest body, string contentType,
            string entityId, string type = null, string options = null)
        {
            UpdateOrAppendEntityAttributesWithHttpInfo(body, contentType, entityId, type, options);
        }

        /// <summary>
        /// Update or Append Entity Attributes The request payload is an object representing the attributes to append or update. The object follows the JSON entity representation format (described in \&quot;JSON Entity Representation\&quot; section), except that &#x60;id&#x60; and &#x60;type&#x60; are not allowed. The entity attributes are updated with the ones in the payload, depending on whether the &#x60;append&#x60; operation option is used or not. * If &#x60;append&#x60; is not used: the entity attributes are updated (if they previously exist) or appended   (if they don&#x27;t previously exist) with the ones in the payload. * If &#x60;append&#x60; is used (i.e. strict append semantics): all the attributes in the payload not   previously existing in the entity are appended. In addition to that, in case some of the   attributes in the payload already exist in the entity, an error is returned. Response: * Successful operation uses 204 No Content * Errors use a non-2xx and (optionally) an error payload. See subsection on \&quot;Error Responses\&quot; for   more details.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"></param>
        /// <param name="contentType"></param>
        /// <param name="entityId">Entity id to be updated</param>
        /// <param name="type">Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)</param>
        /// <param name="options">Operations options (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateOrAppendEntityAttributesWithHttpInfo(
            UpdateOrAppendEntityAttributesRequest body, string contentType, string entityId, string type = null,
            string options = null)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400,
                    "Missing required parameter 'body' when calling EntitiesApi->UpdateOrAppendEntityAttributes");
            // verify the required parameter 'contentType' is set
            if (contentType == null)
                throw new ApiException(400,
                    "Missing required parameter 'contentType' when calling EntitiesApi->UpdateOrAppendEntityAttributes");
            // verify the required parameter 'entityId' is set
            if (entityId == null)
                throw new ApiException(400,
                    "Missing required parameter 'entityId' when calling EntitiesApi->UpdateOrAppendEntityAttributes");

            var localVarPath = "/v2/entities/{entityId}/attrs";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[]
            {
                "application/json"
            };
            String localVarHttpContentType =
                this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[]
            {
            };
            String localVarHttpHeaderAccept =
                this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (entityId != null)
                localVarPathParams.Add("entityId",
                    this.Configuration.ApiClient.ParameterToString(entityId)); // path parameter
            if (type != null)
                localVarQueryParams.AddRange(
                    this.Configuration.ApiClient.ParameterToKeyValuePairs("", "type", type)); // query parameter
            if (options != null)
                localVarQueryParams.AddRange(
                    this.Configuration.ApiClient.ParameterToKeyValuePairs("", "options", options)); // query parameter
            if (contentType != null)
                localVarHeaderParams.Add("Content-Type",
                    this.Configuration.ApiClient.ParameterToString(contentType)); // header parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams,
                localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateOrAppendEntityAttributes", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }

        /// <summary>
        /// Update or Append Entity Attributes The request payload is an object representing the attributes to append or update. The object follows the JSON entity representation format (described in \&quot;JSON Entity Representation\&quot; section), except that &#x60;id&#x60; and &#x60;type&#x60; are not allowed. The entity attributes are updated with the ones in the payload, depending on whether the &#x60;append&#x60; operation option is used or not. * If &#x60;append&#x60; is not used: the entity attributes are updated (if they previously exist) or appended   (if they don&#x27;t previously exist) with the ones in the payload. * If &#x60;append&#x60; is used (i.e. strict append semantics): all the attributes in the payload not   previously existing in the entity are appended. In addition to that, in case some of the   attributes in the payload already exist in the entity, an error is returned. Response: * Successful operation uses 204 No Content * Errors use a non-2xx and (optionally) an error payload. See subsection on \&quot;Error Responses\&quot; for   more details.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"></param>
        /// <param name="contentType"></param>
        /// <param name="entityId">Entity id to be updated</param>
        /// <param name="type">Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)</param>
        /// <param name="options">Operations options (optional)</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task UpdateOrAppendEntityAttributesAsync(
            UpdateOrAppendEntityAttributesRequest body, string contentType, string entityId, string type = null,
            string options = null)
        {
            await UpdateOrAppendEntityAttributesAsyncWithHttpInfo(body, contentType, entityId, type, options);
        }

        /// <summary>
        /// Update or Append Entity Attributes The request payload is an object representing the attributes to append or update. The object follows the JSON entity representation format (described in \&quot;JSON Entity Representation\&quot; section), except that &#x60;id&#x60; and &#x60;type&#x60; are not allowed. The entity attributes are updated with the ones in the payload, depending on whether the &#x60;append&#x60; operation option is used or not. * If &#x60;append&#x60; is not used: the entity attributes are updated (if they previously exist) or appended   (if they don&#x27;t previously exist) with the ones in the payload. * If &#x60;append&#x60; is used (i.e. strict append semantics): all the attributes in the payload not   previously existing in the entity are appended. In addition to that, in case some of the   attributes in the payload already exist in the entity, an error is returned. Response: * Successful operation uses 204 No Content * Errors use a non-2xx and (optionally) an error payload. See subsection on \&quot;Error Responses\&quot; for   more details.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="body"></param>
        /// <param name="contentType"></param>
        /// <param name="entityId">Entity id to be updated</param>
        /// <param name="type">Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)</param>
        /// <param name="options">Operations options (optional)</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> UpdateOrAppendEntityAttributesAsyncWithHttpInfo(
            UpdateOrAppendEntityAttributesRequest body, string contentType, string entityId, string type = null,
            string options = null)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400,
                    "Missing required parameter 'body' when calling EntitiesApi->UpdateOrAppendEntityAttributes");
            // verify the required parameter 'contentType' is set
            if (contentType == null)
                throw new ApiException(400,
                    "Missing required parameter 'contentType' when calling EntitiesApi->UpdateOrAppendEntityAttributes");
            // verify the required parameter 'entityId' is set
            if (entityId == null)
                throw new ApiException(400,
                    "Missing required parameter 'entityId' when calling EntitiesApi->UpdateOrAppendEntityAttributes");

            var localVarPath = "/v2/entities/{entityId}/attrs";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[]
            {
                "application/json"
            };
            String localVarHttpContentType =
                this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[]
            {
            };
            String localVarHttpHeaderAccept =
                this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (entityId != null)
                localVarPathParams.Add("entityId",
                    this.Configuration.ApiClient.ParameterToString(entityId)); // path parameter
            if (type != null)
                localVarQueryParams.AddRange(
                    this.Configuration.ApiClient.ParameterToKeyValuePairs("", "type", type)); // query parameter
            if (options != null)
                localVarQueryParams.AddRange(
                    this.Configuration.ApiClient.ParameterToKeyValuePairs("", "options", options)); // query parameter
            if (contentType != null)
                localVarHeaderParams.Add("Content-Type",
                    this.Configuration.ApiClient.ParameterToString(contentType)); // header parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(
                localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams,
                localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateOrAppendEntityAttributes", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                null);
        }
    }
}